<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pacman XMAS - Classic Mode</title>
<style>
/* CSS DARI V19 UNTUK STABILITAS TAMPILAN */
  html,body{
    margin:0; background:transparent; 
    height:100%; min-height:100vh;
    display:flex; justify-content:center; align-items:flex-start;
    font-family:Arial, Helvetica, sans-serif; padding:12px; box-sizing:border-box;
  }
  #gameWrapper{
    width: calc(20 * 20px + 40px); max-width: 92vw; display:flex;
    flex-direction:column; align-items:center; gap:12px; position: relative;
  }
  canvas{
    background:#071024; /* Latar Belakang Canvas */
    border-radius:10px; display:block;
    box-shadow: 0 8px 24px rgba(0,0,0,0.6); image-rendering: optimizeSpeed;
  }
  #ui{
    position:relative; color:#fff; z-index:2; align-self:flex-start;
    display:flex; justify-content:space-between; width:100%; margin-bottom: -10px;
  }
  #game-message{
    color:white; background:rgba(0,0,0,.8); padding:10px 15px; border-radius:8px;
    display:none; z-index:12; position:absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%); text-align: center;
  }
  /* STYLE UNTUK TOMBOL KONTROL TAMBAHAN */
  #control-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
    display: flex; justify-content: space-between; align-items: flex-start;
    padding: 5px; box-sizing: border-box;
  }
  #escape-button, #reset-button {
    background: #ff0033; color: white; border: none; padding: 5px 10px;
    border-radius: 5px; cursor: pointer; font-size: 14px;
    z-index: 10;
  }
  #escape-button { display: none; } /* Default hidden */


  #mobileControls{
    position:relative; margin-top:6px; display:flex; flex-direction:column;
    align-items:center; gap:8px; user-select:none; -webkit-tap-highlight-color: transparent;
  }
  #mobileControls button{
    width: 70px; height: 70px; border-radius:10px;border:0;
    background:linear-gradient(90deg,#cc0000,#16a34a);color:#fff;font-size:22px;
    display:inline-flex;align-items:center;justify-content:center;
    box-shadow:0 4px rgba(0,0,0,0.4); touch-action: manipulation;
  }
  .dpad-row{display:flex;align-items:center;gap:8px}
  .center-filler{width: 70px; height: 70px;}
  @media(min-width:900px){
    body{align-items:center}
    #gameWrapper{max-width:760px}
    #mobileControls{display:none}
  }
  @media(max-width:480px){
    #gameWrapper{ width: 90vw; }
  }
</style>
</head>

<body>
  <div id="gameWrapper">
    <div id="ui">
        <div>Score: <span id="current-score-display">0</span></div>
        <div id="game-info">
            <span>Lives: <span id="lives-display">1</span></span>
        </div>
    </div>
    
    <div id="control-overlay">
        <button id="escape-button">Kembali ke Menu</button>
        <button id="reset-button">Restart Game</button>
    </div>
    
    <div id="game-message"></div>

    <canvas id="pacman-canvas" aria-label="Pacman XMAS game"></canvas>

    <div id="mobileControls" aria-hidden="false">
      <button data-dir="up" id="btn-up">↑</button>
      <div class="dpad-row">
        <button data-dir="left" id="btn-left">←</button>
        <div class="center-filler" aria-hidden="true"></div>
        <button data-dir="right" id="btn-right">→</button>
      </div>
      <button data-dir="down" id="btn-down">↓</button>
    </div>
  </div>

<script>
(function(){
  const canvas = document.getElementById('pacman-canvas');
  const ctx = canvas ? canvas.getContext('2d') : null;
  const TILE_SIZE = 20;

  // Helper aman
  const $ = (id) => document.getElementById(id);

  const GAME_MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
    [1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,2,1],
    [1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1],
    [1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,0,0,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1],
    [1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1],
    [1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];

  const MAP_WIDTH = GAME_MAP[0].length;
  const MAP_HEIGHT = GAME_MAP.length;
  
  let pacman;
  let ghosts;
  let score = 0;
  let playerLives = 1;
  let gameRunning = false;
  let mapData = [];
  let animationFrameId = null;
  
  // Variabel untuk Game Loop
  let lastTime = 0;
  const GAME_UPDATE_INTERVAL = 200; // Kecepatan Classic
  let gameUpdateTimer = 0;


  function updateScoreDisplay() {
    const scoreEl = $("#current-score-display");
    if(scoreEl) scoreEl.textContent = score;
  }
  function updateLivesDisplay() {
    const livesEl = $("#lives-display");
    if(livesEl) livesEl.textContent = playerLives;
  }

  function resetMapData() {
      mapData = GAME_MAP.map(row => [...row]);
      score = 0;
      pacman = { x: 1, y: 1, dir: 'right', nextDir: 'right', radius: TILE_SIZE / 2.5 };
      ghosts = [
          { x: 9, y: 9, color: '#cc0000', dir: 'up', speed: 1 },
          { x: 10, y: 9, color: '#16a34a', dir: 'down', speed: 1 },
          { x: 8, y: 9, color: '#2563eb', dir: 'left', speed: 1 }
      ];
  }

  function resetGame() {
      if(!canvas || !ctx) {
          console.error("Canvas or Context not available, cannot reset game.");
          return;
      }
      canvas.width = MAP_WIDTH * TILE_SIZE;
      canvas.height = MAP_HEIGHT * TILE_SIZE;
      console.log(`[DEBUG] Canvas dimensions set: ${canvas.width}x${canvas.height}`); 
      
      resetMapData();
      playerLives = 1;
      updateScoreDisplay();
      updateLivesDisplay();
      
      const gm = $('#game-message');
      if(gm) gm.style.display = 'none';
      const eb = $('#escape-button');
      if(eb) eb.style.display = 'none'; // Sembunyikan tombol kembali saat game reset
      
      gameRunning = false;
      drawMap(); 
  }

  function drawMap() {
      if (!ctx) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height); 
      
      for (let y = 0; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
              const type = mapData[y][x];

              if (type === 1) {
                  ctx.fillStyle = '#ff0033'; 
                  ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                  ctx.strokeStyle = '#ffffff';
                  ctx.lineWidth = 1;
                  ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
              } else {
                  if (type === 2) {
                      ctx.fillStyle = '#facc15';
                      ctx.beginPath();
                      ctx.arc(x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 8, 0, Math.PI * 2);
                      ctx.fill();
                  }
              }
          }
      }
  }

  function drawPacman() {
      if (!ctx || !pacman) return;
      const x = pacman.x * TILE_SIZE + TILE_SIZE / 2;
      const y = pacman.y * TILE_SIZE + TILE_SIZE / 2;
      ctx.fillStyle = '#facc15';
      ctx.beginPath();

      const mouthOpen = Math.abs(Math.sin(Date.now() / 100));
      const angleOffset = { 'right': 0, 'left': Math.PI, 'up': -Math.PI / 2, 'down': Math.PI / 2 }[pacman.dir];
      const startAngle = angleOffset + mouthOpen * 0.4;
      const endAngle = angleOffset - mouthOpen * 0.4 + 2 * Math.PI;

      ctx.arc(x, y, pacman.radius, startAngle, endAngle, false);
      ctx.lineTo(x, y);
      ctx.closePath();
      ctx.fill();
  }

  function drawGhosts() {
      if (!ctx || !ghosts) return;
      ghosts.forEach(ghost => {
          const x = ghost.x * TILE_SIZE + TILE_SIZE / 2;
          const y = ghost.y * TILE_SIZE + TILE_SIZE / 2;

          ctx.fillStyle = ghost.color;
          ctx.beginPath();
          ctx.arc(x, y, TILE_SIZE / 2, Math.PI, 0, false);
          ctx.rect(x - TILE_SIZE / 2, y, TILE_SIZE, TILE_SIZE / 2);
          const wobble = Math.sin(Date.now() / 200) * 2;
          ctx.moveTo(x - TILE_SIZE / 2, y + TILE_SIZE / 2);
          ctx.lineTo(x - TILE_SIZE / 2 + TILE_SIZE / 4 + wobble, y + TILE_SIZE / 2 - 3);
          ctx.lineTo(x, y + TILE_SIZE / 2);
          ctx.lineTo(x + TILE_SIZE / 2 - TILE_SIZE / 4 - wobble, y + TILE_SIZE / 2 - 3);
          ctx.lineTo(x + TILE_SIZE / 2, y + TILE_SIZE / 2);
          ctx.fill();

          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.arc(x - TILE_SIZE / 4, y - TILE_SIZE / 4, TILE_SIZE / 8, 0, Math.PI * 2);
          ctx.arc(x + TILE_SIZE / 4, y - TILE_SIZE / 4, TILE_SIZE / 8, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = 'black';
          ctx.beginPath();
          ctx.arc(x - TILE_SIZE / 4 + 1, y - TILE_SIZE / 4, TILE_SIZE / 16, 0, Math.PI * 2);
          ctx.arc(x + TILE_SIZE / 4 + 1, y - TILE_SIZE / 4, TILE_SIZE / 16, 0, Math.PI * 2);
          ctx.fill();
      });
  }

  function movePacman() {
      const nextX = pacman.x + (pacman.nextDir === 'right' ? 1 : pacman.nextDir === 'left' ? -1 : 0);
      const nextY = pacman.y + (pacman.nextDir === 'down' ? 1 : pacman.nextDir === 'up' ? -1 : 0);

      if (mapData[nextY] && mapData[nextY][nextX] !== 1) {
          pacman.dir = pacman.nextDir;
          pacman.x = nextX;
          pacman.y = nextY;
      } else {
          const currentX = pacman.x + (pacman.dir === 'right' ? 1 : pacman.dir === 'left' ? -1 : 0);
          const currentY = pacman.y + (pacman.dir === 'down' ? 1 : pacman.dir === 'up' ? -1 : 0);

          if (mapData[currentY] && mapData[currentY][currentX] !== 1) {
              pacman.x = currentX;
              pacman.y = currentY;
          }
      }

      // Teleport
      if (pacman.x < 0) pacman.x = MAP_WIDTH - 1;
      if (pacman.x >= MAP_WIDTH) pacman.x = 0;
  }

  function moveGhosts() {
      ghosts.forEach(ghost => {
          const possibleMoves = [];
          const moves = [
              { dx: 1, dy: 0, dir: 'right' },
              { dx: -1, dy: 0, dir: 'left' },
              { dx: 0, dy: 1, dir: 'down' },
              { dx: 0, dy: -1, dir: 'up' }
          ];

          moves.forEach(move => {
              const nextX = ghost.x + move.dx;
              const nextY = ghost.y + move.dy;

              if (mapData[nextY] && mapData[nextY][nextX] !== 1) {
                  possibleMoves.push(move);
              }
          });

          if (possibleMoves.length > 0) {
              possibleMoves.sort((a,b)=>{
                const ax = ghost.x + a.dx - pacman.x; const ay = ghost.y + a.dy - pacman.y;
                const bx = ghost.x + b.dx - pacman.x; const by = ghost.y + b.dy - pacman.y;
                const da = Math.hypot(ax,ay), db = Math.hypot(bx,by);
                return da - db;
              });
              const pick = Math.random() < 0.7 ? possibleMoves[0] : possibleMoves[Math.floor(Math.random()*possibleMoves.length)];
              ghost.x += pick.dx;
              ghost.y += pick.dy;
              ghost.dir = pick.dir;
          }
      });
  }

  function checkCollision() {
      if (mapData[pacman.y][pacman.x] === 2) {
          mapData[pacman.y][pacman.x] = 0;
          score += 10;
          updateScoreDisplay(); 
      }

      ghosts.forEach(ghost => {
          if (pacman.x === ghost.x && pacman.y === ghost.y) {
              playerLives--;
              updateLivesDisplay();
              if (playerLives <= 0) {
                  endGame(false);
              } else {
                  // Reset posisi setelah ditabrak
                  pacman = { x: 1, y: 1, dir: 'right', nextDir: 'right', radius: TILE_SIZE / 2.5 };
                  ghosts = [
                      { x: 9, y: 9, color: '#cc0000', dir: 'up', speed: 1 },
                      { x: 10, y: 9, color: '#16a34a', dir: 'down', speed: 1 },
                      { x: 8, y: 9, color: '#2563eb', dir: 'left', speed: 1 }
                  ];
              }
          }
      });

      let dotsRemaining = mapData.flat().filter(cell => cell === 2).length;
      if (dotsRemaining === 0) endGame(true);
  }


  function gameLoop(timestamp) {
      if (!gameRunning) {
        animationFrameId = requestAnimationFrame(gameLoop);
        drawMap(); 
        drawPacman();
        drawGhosts();
        return;
      }
      
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      
      drawMap();
      drawPacman();
      drawGhosts();

      gameUpdateTimer += deltaTime;
      if (gameUpdateTimer > GAME_UPDATE_INTERVAL) {
          movePacman();
          moveGhosts();
          checkCollision();
          gameUpdateTimer = 0;
      }

      animationFrameId = requestAnimationFrame(gameLoop);
  }

  function handleReturnHome() {
    window.parent.postMessage({ type: 'returnHome' }, '*');
  }
  
  function handleGameRestart() {
    if (gameRunning) return; // Jangan restart jika sedang berjalan
    resetGame();
    // Jika gameRunning false (mode statis) saat ini, kita harus mensimulasikan 'paySuccess'
    // untuk memulai loop aktif.
    gameRunning = true;
    lastTime = performance.now();
  }

  function endGame(isWin) {
      if (!gameRunning) return;
      gameRunning = false;
      cancelAnimationFrame(animationFrameId);
      const msg = isWin ? "SELAMAT! Anda menang!" : "GAME OVER!";
      const gm = $('#game-message');
      const eb = $('#escape-button');
      
      gm.textContent = msg + " Skor Akhir: " + score;
      gm.style.display = 'block';
      if(eb) eb.style.display = 'block'; // Tampilkan tombol kembali manual
      
      window.parent.postMessage({ type: 'submitScore', score: score, modeName: 'Classic' }, '*');
      
      setTimeout(()=>{
        gm.style.display = 'none';
        handleReturnHome();
      }, 4000);
  }

  // Input Keyboard
  const handleGlobalKeydown = (e) => {
      let dir = null;
      if (e.key === 'ArrowUp' || e.key === 'w') dir = 'up';
      else if (e.key === 'ArrowDown' || e.key === 's') dir = 'down';
      else if (e.key === 'ArrowLeft' || e.key === 'a') dir = 'left';
      else if (e.key === 'ArrowRight' || e.key === 'd') dir = 'right';
      if(dir) pacman.nextDir = dir;
  };
  
  // LOGIC INPUT MOBILE BARU: Menggunakan mousedown/touchstart untuk trigger pergerakan
  const handleMobileInput = (e) => {
    // Pastikan ini adalah event sentuhan/mouse yang valid
    if (e.type !== 'touchstart' && e.type !== 'mousedown') return;
    
    // Mencegah browser default action (seperti scrolling)
    e.preventDefault(); 
    
    const btn = e.target.closest('button');
    if (btn && btn.dataset.dir) {
        pacman.nextDir = btn.dataset.dir;
    }
  };

  // receive messages from parent
  window.addEventListener('message', (ev)=>{
    const d = ev.data || {};
    if (d.type === 'paySuccess') {
      resetGame();
      gameRunning = true;
      lastTime = performance.now();
    }
  });

/* ========== STARTUP SAAT DOM DIMUAT ========== */
document.addEventListener('DOMContentLoaded', () => {
    // Tambahkan listener ke tombol escape/kembali dan reset
    const escapeButton = $("#escape-button");
    const resetButton = $("#reset-button");
    if (escapeButton) {
        escapeButton.addEventListener('click', handleReturnHome);
    }
    if (resetButton) {
        resetButton.addEventListener('click', handleGameRestart);
    }
    
    // 1. Inisialisasi Game State
    resetGame();
    
    // 2. Tambahkan Listener Input Keyboard
    document.addEventListener('keydown', handleGlobalKeydown); 
    
    // Mobile Controls: Menggunakan MOUSE DOWN & TOUCH START
    const mobileControls = $("#mobileControls");
    if(mobileControls){
        // Tambahkan listener ke seluruh wrapper kontrol mobile
        mobileControls.addEventListener('touchstart', handleMobileInput);
        mobileControls.addEventListener('mousedown', handleMobileInput);
    }

    // 3. MULAI LOOP UTAMA
    requestAnimationFrame(gameLoop); 
 
});
})();
</script>
</body>
</html>

