<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Halloween Labyrinth</title>
    <!-- Tailwind CSS for styling and responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons for direction arrows -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            color: white;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #game-container {
            /* Max width untuk frame game yang lebih besar */
            max-width: 1000px; 
            width: 100%;
            margin-bottom: 1rem;
            border: 4px solid #7B00FF;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(123, 0, 255, 0.5);
        }
        canvas {
            display: block;
            background-color: #000000;
            width: 100%; 
            height: auto;
            /* Mempertahankan rasio aspek 4:3 (800/600) untuk konsistensi game */
            aspect-ratio: 4 / 3; 
        }
        .control-grid {
            grid-template-areas:
                ". up ."
                "left center right"
                ". down .";
            /* Mengurangi lebar grid kontrol */
            width: 200px; 
            margin-top: 1rem;
        }
        .control-btn {
            background-color: #FF6600; 
            color: #1a1a2e;
            border-radius: 9999px; 
            /* Ukuran tombol agar lebih kecil */
            padding: 1rem;
            box-shadow: 0 4px 0 #D35400;
            transition: all 0.1s;
            cursor: pointer;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .control-btn:active {
            box-shadow: 0 0 0 #D35400;
            transform: translateY(4px);
        }
        #gameOverModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- Modal Game Over -->
    <div id="gameOverModal" class="flex flex-col p-8 rounded-xl bg-gray-900 border-4 border-yellow-500 shadow-2xl w-11/12 max-w-sm">
        <h2 id="modalTitle" class="text-3xl font-extrabold mb-4 text-center text-yellow-400"></h2>
        <p id="modalMessage" class="text-lg text-center mb-6"></p>
        <button onclick="hideMessage();" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-bold">
            Tutup
        </button>
    </div>

    <header class="w-full max-w-xl flex justify-between items-center p-4 bg-gray-800 rounded-lg mb-4 shadow-lg">
        <h1 class="text-xl font-bold flex items-center">
            <span class="text-3xl mr-2">ðŸŽƒ</span> Halloween Maze
        </h1>
        <div class="text-lg">Score: <span id="score" class="font-extrabold text-yellow-400">0</span></div>
    </header>

    <div id="game-container">
        <canvas id="game" width="800" height="600"></canvas>
    </div>

    <!-- Kontrol Mobile -->
    <div class="control-grid grid grid-cols-3 gap-2">
        <button id="up-btn" class="control-btn" style="grid-area: up;" ontouchstart="setDirection(2)" ontouchend="stopDirection()" onmousedown="setDirection(2)" onmouseup="stopDirection()">
            <i data-lucide="arrow-up" class="w-6 h-6"></i>
        </button>
        <button id="left-btn" class="control-btn" style="grid-area: left;" ontouchstart="setDirection(1)" ontouchend="stopDirection()" onmousedown="setDirection(1)" onmouseup="stopDirection()">
            <i data-lucide="arrow-left" class="w-6 h-6"></i>
        </button>
        <div style="grid-area: center;"></div> 
        <button id="right-btn" class="control-btn" style="grid-area: right;" ontouchstart="setDirection(0)" ontouchend="stopDirection()" onmousedown="setDirection(0)" onmouseup="stopDirection()">
            <i data-lucide="arrow-right" class="w-6 h-6"></i>
        </button>
        <button id="down-btn" class="control-btn" style="grid-area: down;" ontouchstart="setDirection(3)" ontouchend="stopDirection()" onmousedown="setDirection(3)" onmouseup="stopDirection()">
            <i data-lucide="arrow-down" class="w-6 h-6"></i>
        </button>
    </div>

    <!-- Tombol Web3 -->
    <div class="flex flex-wrap justify-center gap-4 mt-8 w-full max-w-md">
        <button id="startOnchainBtn" onclick="startGameTransaction()" class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-xl transition duration-150">
            START GAME (Bayar 0.01 SOMI)
        </button>
        <button onclick="backMenu()" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-xl transition duration-150">
            BACK TO MENU
        </button>
    </div>

    <script type="module">
        // ====================================================================
        // --- 1. INISIALISASI FIREBASE DAN OTENTIKASI (Hanya untuk Submission Skor) ---
        // KODE INI DIPERLUKAN UNTUK MENGIRIM SKOR KE LEDGER PUBLIK (FIREBASE)
        // ====================================================================
        
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserSessionPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // setLogLevel('debug'); 

        let db = null;
        let auth = null;
        let userId = null;
        let firebaseReady = false; 
        
        const startGameButton = document.getElementById("startOnchainBtn");

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const EMPTY_CONFIG_FALLBACK = '{"apiKey":"AIzaSyB-fallback","authDomain":"projectId.firebaseapp.com","projectId":"fallback-project","storageBucket":"projectId.appspot.com","messagingSenderId":"123456789012","appId":"1:123456789012:web:abac123456789012"}';

        function getFirebaseConfig() {
            const rawConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
            let config = null;

            if (rawConfig && typeof rawConfig === 'string' && rawConfig.trim() !== '') {
                try { config = JSON.parse(rawConfig); } catch (e) { console.error("Gagal parse Config sistem."); }
            }
            
            if (!config || Object.keys(config).length === 0) {
                 try {
                    config = JSON.parse(EMPTY_CONFIG_FALLBACK);
                    console.warn("Menggunakan konfigurasi fallback. Skor mungkin tidak tersimpan.");
                } catch (e) {
                    return null;
                }
            }
            return config;
        }

        async function initializeFirebaseAndAuth() {
            const firebaseConfig = getFirebaseConfig();

            if (!firebaseConfig) {
                console.error("Firebase GAGAL: Config tidak tersedia.");
                return;
            }

            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                await setPersistence(auth, browserSessionPersistence);
                
                if (initialAuthToken) { 
                    await signInWithCustomToken(auth, initialAuthToken); 
                } else { 
                    await signInAnonymously(auth); 
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        firebaseReady = true;
                        console.log("Firebase Siap: Skor akan dikirim sebagai user:", userId.substring(0, 8) + '...');
                    } else {
                        userId = null;
                        firebaseReady = false;
                        console.warn("Firebase Gagal Otentikasi. Skor tidak akan tersimpan.");
                    }
                });

            } catch (error) {
                console.error("Error Firebase Init/Auth:", error);
                firebaseReady = false;
            }
        }
        
        /** SUBMIT SCORE KE FIREBASE (PUBLIC LEDGER) */
        async function submitFinalScore(score) {
            if (!firebaseReady || !userId || !db) {
                console.warn("Skor tidak disimpan: Firebase tidak siap atau otentikasi gagal.");
                return;
            }
            
            const scoreData = {
                score: score,
                userId: userId,
                timestamp: Date.now(),
                app: appId 
            };
            
            try {
                // MENGGUNAKAN PATH PUBLIC FIREBASE SEBAGAI SIMULASI LEDGER ON-CHAIN
                const path = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
                // Menggunakan doc() tanpa argumen untuk membuat ID baru
                await setDoc(doc(path), scoreData); 
                console.log(`Skor ${score} berhasil dikirim ke Public Ledger (untuk Leaderboard luar).`);
            } catch (e) {
                console.error("Error saat mengirim skor ke Public Leaderboard: ", e);
            }
        }

        // ====================================================================
        // --- 2. LOGIKA GAME PAC-MAN CORE ---
        // ====================================================================

        lucide.createIcons();

        let running = false;
        let currentScore = 0; 
        const PLAYER_SPEED = 3.5; 
        const GHOST_SIZE = 20; 
        const PLAYER_SIZE = 30; 
        const CANDY_VALUE = 10; 
        
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");

        let x = 400; let y = 300; let vx = 0; let vy = 0; let currentDirection = 0; 

        // Fungsi Modal (Mengganti alert)
        window.showMessage = (title, message) => {
            document.getElementById("modalTitle").innerText = title;
            document.getElementById("modalMessage").innerText = message;
            document.getElementById("gameOverModal").style.display = 'flex';
        }

        window.hideMessage = () => {
            document.getElementById("gameOverModal").style.display = 'none';
        }

        // Fungsi Kontrol Mobile
        window.setDirection = (direction) => {
            if (!running) return;
            currentDirection = direction;
            vx = 0; vy = 0;
            if (direction === 0) { vx = PLAYER_SPEED; } 
            else if (direction === 1) { vx = -PLAYER_SPEED; } 
            else if (direction === 2) { vy = -PLAYER_SPEED; } 
            else if (direction === 3) { vy = PLAYER_SPEED; } 
        }

        window.stopDirection = () => {
            vx = 0;
            vy = 0;
        }

        // Definisi Dinding
        const WALL_THICKNESS = 20;
        const walls = [
            { x: 0, y: 0, width: 800, height: WALL_THICKNESS }, { x: 0, y: 580, width: 800, height: WALL_THICKNESS }, 
            { x: 0, y: 0, width: WALL_THICKNESS, height: 600 }, { x: 780, y: 0, width: WALL_THICKNESS, height: 600 }, 
            { x: 300, y: 280, width: 200, height: WALL_THICKNESS }, 
            { x: 100, y: 100, width: 200, height: WALL_THICKNESS }, { x: 100, y: 100, width: WALL_THICKNESS, height: 100 },
            { x: 100, y: 480, width: 200, height: WALL_THICKNESS }, { x: 100, y: 400, width: WALL_THICKNESS, height: 100 },
            { x: 500, y: 100, width: 200, height: WALL_THICKNESS }, { x: 680, y: 100, width: WALL_THICKNESS, height: 100 },
            { x: 500, y: 480, width: 200, height: WALL_THICKNESS }, { x: 680, y: 400, width: WALL_THICKNESS, height: 100 },
            { x: 380, y: 100, width: 40, height: WALL_THICKNESS }, { x: 390, y: 120, width: WALL_THICKNESS, height: 80 },
            { x: 380, y: 480, width: 40, height: WALL_THICKNESS }, { x: 390, y: 400, width: WALL_THICKNESS, height: 80 },
            { x: 200, y: 200, width: WALL_THICKNESS, height: 80 }, { x: 220, y: 260, width: 80, height: WALL_THICKNESS },
            { x: 580, y: 200, width: WALL_THICKNESS, height: 80 }, { x: 500, y: 260, width: 80, height: WALL_THICKNESS },
            { x: 200, y: 400, width: WALL_THICKNESS, height: 80 }, { x: 220, y: 400, width: 80, height: WALL_THICKNESS },
            { x: 580, y: 400, width: WALL_THICKNESS, height: 80 }, { x: 500, y: 400, width: 80, height: WALL_THICKNESS },
        ];

        function drawWalls() {
            ctx.fillStyle = "rgba(0, 100, 255, 0.8)"; 
            for (const wall of walls) { ctx.fillRect(wall.x, wall.y, wall.width, wall.height); }
        }

        function checkAABBCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect2.height > rect2.y;
        }

        function checkPlayerWallCollision(newX, newY) {
            const playerRect = { x: newX - PLAYER_SIZE, y: newY - PLAYER_SIZE, width: 2 * PLAYER_SIZE, height: 2 * PLAYER_SIZE };
            for (const wall of walls) {
                if (checkAABBCollision(playerRect, wall)) { return true; }
            }
            return false; 
        }

        // Class dan Logika Ghost
        let ghosts = [];
        class Ghost {
            constructor(x, y, color, behavior, speed) {
                this.x = x; this.y = y; this.color = color; this.behavior = behavior; this.speed = speed;
                this.radius = GHOST_SIZE; this.randomMoveCooldown = 0; this.vx = 0; this.vy = 0;
            }
        }
        
        function moveGhost(ghost) {
            let targetX = x, targetY = y;
            let dx = 0, dy = 0;

            if (ghost.behavior === "chase" || ghost.behavior === "flee") {
                dx = targetX - ghost.x; dy = targetY - ghost.y;
                if (ghost.behavior === "flee") { dx *= -1; dy *= -1; }
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    ghost.vx = (dx / distance) * ghost.speed;
                    ghost.vy = (dy / distance) * ghost.speed;
                }
            } else if (ghost.behavior === "random") {
                ghost.randomMoveCooldown--;
                if (ghost.randomMoveCooldown <= 0) {
                    ghost.vx = (Math.random() - 0.5) * ghost.speed * 2;
                    ghost.vy = (Math.random() - 0.5) * ghost.speed * 2;
                    ghost.randomMoveCooldown = 60; 
                }
            }
            
            const newX = ghost.x + ghost.vx;
            const newY = ghost.y + ghost.vy;
            const ghostRect = { x: newX - ghost.radius, y: newY - ghost.radius, width: 2 * ghost.radius, height: 2 * ghost.radius };
            
            let collided = false;
            for (const wall of walls) {
                if (checkAABBCollision(ghostRect, wall)) {
                    collided = true;
                    if (ghost.vx !== 0) ghost.vx *= -1;
                    if (ghost.vy !== 0) ghost.vy *= -1;
                    if (ghost.behavior === "random") { ghost.randomMoveCooldown = 0; }
                    break;
                }
            }

            if (!collided) {
                ghost.x = newX;
                ghost.y = newY;
            }
        }

        function drawGhost(ghost) {
            const r = ghost.radius;
            ctx.fillStyle = ghost.color;
            ctx.beginPath();
            ctx.arc(ghost.x, ghost.y - r / 2, r, Math.PI, 0, false);
            ctx.lineTo(ghost.x + r, ghost.y + r);
            ctx.lineTo(ghost.x + r * 0.75, ghost.y + r - 5);
            ctx.lineTo(ghost.x + r * 0.5, ghost.y + r);
            ctx.lineTo(ghost.x - r, ghost.y + r);
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(ghost.x - r / 2, ghost.y - r / 2, 4, 0, 2 * Math.PI);
            ctx.arc(ghost.x + r / 2, ghost.y - r / 2, 4, 0, 2 * Math.PI);
            ctx.fill();
        }

        function checkCollision(ghost) {
            const distance = Math.sqrt(Math.pow(x - ghost.x, 2) + Math.pow(y - ghost.y, 2));
            return distance < PLAYER_SIZE + ghost.radius; 
        }

        // Logika Candy
        let candy = [];
        function setupCandy() {
            candy = [];
            const rows = 15; const cols = 20; 
            const paddingX = 40; const paddingY = 40;
            const spacingX = (canvas.width - 2 * paddingX) / (cols - 1);
            const spacingY = (canvas.height - 2 * paddingY) / (rows - 1);
            const candyRectSize = 10; 

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const candyX = paddingX + c * spacingX;
                    const candyY = paddingY + r * spacingY;
                    
                    if (Math.abs(candyX - 400) < 60 && Math.abs(candyY - 300) < 60) continue; 
                    
                    let isInsideWall = false;
                    const candyRect = {
                        x: candyX - candyRectSize / 2, y: candyY - candyRectSize / 2, 
                        width: candyRectSize, height: candyRectSize
                    };

                    for (const wall of walls) {
                        const collisionMargin = 5; 
                        const wallCheck = {
                            x: wall.x - collisionMargin, y: wall.y - collisionMargin,
                            width: wall.width + 2 * collisionMargin, height: wall.height + 2 * collisionMargin
                        };
                        
                        if (checkAABBCollision(candyRect, wallCheck)) {
                            isInsideWall = true;
                            break;
                        }
                    }

                    if (!isInsideWall) {
                        candy.push({ x: candyX, y: candyY });
                    }
                }
            }
        }

        function drawCandy() {
            ctx.fillStyle = "orange";
            for (const item of candy) {
                const radius = 6;
                ctx.beginPath();
                ctx.arc(item.x, item.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = "green"; 
                ctx.fillRect(item.x - 1, item.y - radius - 3, 2, 3);
            }
        }

        function checkCandyCollection() {
            for (let i = candy.length - 1; i >= 0; i--) {
                const item = candy[i];
                const distance = Math.sqrt(Math.pow(x - item.x, 2) + Math.pow(y - item.y, 2));

                if (distance < PLAYER_SIZE) {
                    currentScore += CANDY_VALUE;
                    candy.splice(i, 1); 

                    if (candy.length === 0) {
                        endGame(true); 
                        return true;
                    }
                }
            }
            return false;
        }

        /** Menggambar Pacman. */
        function drawPacman() {
            const radius = PLAYER_SIZE;
            let startAngle = 0;
            let endAngle = 2 * Math.PI;

            const mouthOpenness = Math.sin(Date.now() / 100) * 0.2 + 0.5;
            const mouthAngle = mouthOpenness * Math.PI / 4;

            switch (currentDirection) {
                case 0: startAngle = mouthAngle; endAngle = 2 * Math.PI - mouthAngle; break; 
                case 1: startAngle = Math.PI + mouthAngle; endAngle = 3 * Math.PI - mouthAngle; break; 
                case 2: startAngle = 1.5 * Math.PI + mouthAngle; endAngle = 3.5 * Math.PI - mouthAngle; break; 
                case 3: startAngle = 0.5 * Math.PI + mouthAngle; endAngle = 2.5 * Math.PI - mouthAngle; break; 
            }
            
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, endAngle);
            ctx.lineTo(x, y);
            ctx.closePath();
            ctx.fill();
        }

        /** Game Loop Utama */
        function loop() {
            requestAnimationFrame(loop);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!running) {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = "30px 'Inter', sans-serif";
                ctx.fillText("Klik START untuk Bermain!", canvas.width / 2, canvas.height / 2);
                return;
            }
            
            drawWalls();

            const newX = x + vx;
            const newY = y + vy;

            if (!checkPlayerWallCollision(newX, y)) { x = newX; } else { vx = 0; }
            if (!checkPlayerWallCollision(x, newY)) { y = newY; } else { vy = 0; }

            const minBound = WALL_THICKNESS + PLAYER_SIZE;
            const maxBoundX = canvas.width - WALL_THICKNESS - PLAYER_SIZE;
            const maxBoundY = canvas.height - WALL_THICKNESS - PLAYER_SIZE;

            if (x < minBound) x = minBound;
            if (x > maxBoundX) x = maxBoundX;
            if (y < minBound) y = minBound;
            if (y > maxBoundY) y = maxBoundY;
            
            drawPacman();
            drawCandy();
            checkCandyCollection();
            
            for (const ghost of ghosts) {
                moveGhost(ghost);
                drawGhost(ghost);

                if (checkCollision(ghost)) {
                    endGame(false); 
                    return; 
                }
            }
            
            scoreEl.innerText = currentScore;
        }

        // ====================================================================
        // --- 3. FUNGSI TRANSAKSI & KONTROL UTAMA ---
        // ====================================================================
        
        /**
         * FUNGSI SIMULASI TRANSAKSI SOMNIA MAINNET
         */
        async function simulateSomniaTx() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    console.log("[SOMNIA MAINNET] Simulasi transaksi 0.01 SOMI berhasil.");
                    resolve(true); 
                }, 500); 
            });
        }

        /** Dipanggil saat tombol "START GAME" ditekan. */
        window.startGameTransaction = async () => {
            if (running) return;

            startGameButton.disabled = true;
            startGameButton.innerText = "Memproses Transaksi SOMI...";

            const txSuccess = await simulateSomniaTx(); 

            if (txSuccess) {
                startGameLoop();
                showMessage("Transaksi Berhasil", "Pembayaran 0.01 SOMI disimulasikan sukses! Game dimulai.");
            } else {
                showMessage("Kesalahan Transaksi", "Transaksi ke Somnia Mainnet gagal. Coba lagi.");
                startGameButton.disabled = false;
                startGameButton.innerText = "START GAME (Bayar 0.01 SOMI)";
            }
        }

        /** Memulai Game Loop */
        function startGameLoop() {
            running = true;
            currentScore = 0;
            
            ghosts = [
                new Ghost(50, 50, "#FF0000", "chase", 2.0), new Ghost(750, 50, "#00FFFF", "random", 2.0),    
                new Ghost(750, 550, "#FF69B4", "flee", 1.5)       
            ];
            
            setupCandy();
            x = 400; y = 300; vx = 0; vy = 0; currentDirection = 0;
            
            scoreEl.innerText = currentScore; 
            document.getElementById("startOnchainBtn").innerText = "GAME RUNNING...";
        }

        /** Dipanggil ketika game over/win. */
        function endGame(isWin) {
            if (!running) return;
            running = false;
            
            const title = isWin ? "SELAMAT! ðŸ†" : "GAME OVER!";
            const message = isWin 
                ? `Anda memenangkan permainan! Skor Akhir: ${currentScore}`
                : `Anda tertangkap hantu. Skor Akhir: ${currentScore}. Coba lagi!`;
            
            showMessage(title, message);
            
            // --- HANYA MENGIRIM SKOR (TANPA MENAMPILKAN LEADERBOARD) ---
            if (currentScore > 0) {
                submitFinalScore(currentScore); 
            }
            
            startGameButton.disabled = false;
            startGameButton.innerText = "START GAME (Bayar 0.01 SOMI)";
        }

        /** Navigasi kembali ke menu (simulasi reload). */
        window.backMenu = () => {
            window.location.reload();
        }

        // --- INISIASI APLIKASI: Mulai Auth Firebase dan Game Loop ---
        initializeFirebaseAndAuth();
        window.onload = loop; 
    </script>
</body>
</html>
