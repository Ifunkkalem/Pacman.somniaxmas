<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pacman Natal - Final</title>
<style>
  html,body{height:100%;margin:0;background:#000;display:flex;align-items:center;justify-content:center;font-family:Trebuchet MS;overflow:hidden}
  #ui{position:fixed;top:10px;left:10px;color:#fff;z-index:99}
  #gameMessage{position:fixed;top:8px;right:8px;color:#fff;z-index:99}
  canvas{background:#071024;border-radius:8px;box-shadow:0 0 25px #00ffcc,inset 0 0 20px #00ffcc;display:block;max-width:95vw;height:auto}
  #mobileControls{position:fixed;bottom:12px;left:50%;transform:translateX(-50%);display:flex;gap:12px;z-index:99}
  .ctl-btn{width:64px;height:64px;border-radius:50%;border:none;background:linear-gradient(90deg,#ef4444,#10b981);color:#fff;font-size:22px;box-shadow:0 6px 18px rgba(0,0,0,0.4)}
  #levelPanel{position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;flex-direction:column;color:#fff;z-index:200}
  .levelBtn{margin:10px;padding:14px 26px;font-size:20px;border-radius:12px;border:none;background:#fbbf24;color:#000;cursor:pointer}
  #countdown{position:fixed;inset:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;font-size:120px;font-weight:bold;color:gold;z-index:300;text-shadow:0 0 30px gold}
  #victoryOverlay{position:fixed;inset:0;background:radial-gradient(circle,#00ffcc33,#000);display:none;align-items:center;justify-content:center;font-size:48px;font-weight:bold;color:gold;z-index:400;text-shadow:0 0 20px gold}
  /* sparkles & shake */
  .coin-sparkle{position:absolute;pointer-events:none;width:10px;height:10px;border-radius:50%;background:gold;opacity:1;animation:sparkle 0.6s forwards;z-index:110}
  @keyframes sparkle{from{transform:scale(1);opacity:1}to{transform:scale(2.8);opacity:0}}
  .shake{animation:shake 0.42s}
  @keyframes shake{0%{transform:translate(2px,1px)}25%{transform:translate(-2px,-3px)}50%{transform:translate(3px,2px)}75%{transform:translate(-2px,2px)}100%{transform:translate(0,0)}}
  /* snow */
  .snow{position:fixed;top:-10px;color:white;font-size:12px;opacity:0.9;animation:fall linear forwards;z-index:10}
  @keyframes fall{to{transform:translateY(110vh)}}
  /* responsive tweak */
  @media (min-width:900px){
    canvas{max-width:800px}
    .ctl-btn{width:56px;height:56px}
  }
</style>
</head>
<body>

<div id="ui">
  <div id="current-score-display">0</div>
  <div id="game-message" style="display:none;background:rgba(0,0,0,0.6);padding:6px;border-radius:6px;margin-top:6px"></div>
</div>

<canvas id="pacman-canvas"></canvas>

<!-- Mobile controls -->
<div id="mobileControls">
  <button class="ctl-btn" data-dir="up">‚Üë</button>
  <button class="ctl-btn" data-dir="left">‚Üê</button>
  <button class="ctl-btn" data-dir="down">‚Üì</button>
  <button class="ctl-btn" data-dir="right">‚Üí</button>
</div>

<!-- Level panel (appears after pay) -->
<div id="levelPanel">
  <h2 style="margin:0 0 12px 0;color:#fff">Pilih Level</h2>
  <button class="levelBtn" onclick="setLevel('easy')">EASY</button>
  <button class="levelBtn" onclick="setLevel('normal')">NORMAL</button>
  <button class="levelBtn" onclick="setLevel('hard')">HARD</button>
</div>

<!-- Countdown and victory -->
<div id="countdown">3</div>
<div id="victoryOverlay">üèÜ YOU WIN!</div>

<!-- Audio (CDN) -->
<audio id="bgm" loop src="https://cdn.pixabay.com/audio/2022/10/25/audio_87c07c7a1f.mp3"></audio>
<audio id="sndCoin" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-coin-216.wav"></audio>
<audio id="sndWin" src="https://assets.mixkit.co/sfx/preview/mixkit-ethereal-fairy-win-sound-2019.wav"></audio>
<audio id="sndLose" src="https://assets.mixkit.co/sfx/preview/mixkit-arcade-retro-game-over-213.wav"></audio>

<script>
/* -------------------------
   FULL GAME + UPGRADES
   ------------------------- */

/* CONFIG */
const TILE_SIZE = 20; // keep same characters scale
const canvas = document.getElementById('pacman-canvas');
const ctx = canvas.getContext('2d');

/* MAP (unchanged labyrinth) */
const GAME_MAP = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
  [1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,2,1],
  [1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1],
  [1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],
  [0,0,0,0,1,2,1,0,0,0,0,0,0,1,2,1,0,0,0,0],
  [1,1,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1],
  [1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1],
  [1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
  [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const MAP_WIDTH = GAME_MAP[0].length;
const MAP_HEIGHT = GAME_MAP.length;

/* keep pixel-perfect canvas size */
canvas.width = MAP_WIDTH * TILE_SIZE;
canvas.height = MAP_HEIGHT * TILE_SIZE;

/* GAME STATE */
let pacman, ghosts, score, gameRunning=false, mapData=[];
let animationFrameId=null;
let lastTime=0;
let GAME_UPDATE_INTERVAL = 150; // default normal

/* RESET & INIT */
function resetMapData(){
  mapData = GAME_MAP.map(row=>[...row]);
  score = 0;
  pacman = { x:1, y:1, dir:'right', nextDir:'right', radius:TILE_SIZE/2.5 };
  ghosts = [
    { x:9, y:9, color:'#cc0000', dir:'up' },
    { x:10, y:9, color:'#16a34a', dir:'down' },
    { x:8, y:9, color:'#2563eb', dir:'left' }
  ];
  document.getElementById('current-score-display').textContent = score;
}

function resetGame(){
  resetMapData();
  gameRunning=false;
  const gm=document.getElementById('game-message'); gm.style.display='none';
  drawOnce();
}

/* DRAW */
function drawMap(){
  for(let y=0;y<MAP_HEIGHT;y++){
    for(let x=0;x<MAP_WIDTH;x++){
      const t=mapData[y][x];
      if(t===1){
        ctx.fillStyle='#b91c1c';
        ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
        ctx.strokeStyle='#ffffff'; ctx.lineWidth=1;
        ctx.strokeRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
      } else {
        ctx.fillStyle='#020617';
        ctx.fillRect(x*TILE_SIZE,y*TILE_SIZE,TILE_SIZE,TILE_SIZE);
        if(t===2){
          ctx.fillStyle='#facc15';
          ctx.beginPath();
          ctx.arc(x*TILE_SIZE+TILE_SIZE/2,y*TILE_SIZE+TILE_SIZE/2, Math.max(2, TILE_SIZE/8),0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}

function drawPacman(){
  const x = pacman.x*TILE_SIZE + TILE_SIZE/2;
  const y = pacman.y*TILE_SIZE + TILE_SIZE/2;
  ctx.fillStyle = '#facc15';
  ctx.beginPath();
  const mouthOpen = Math.abs(Math.sin(Date.now()/100));
  const angleOffset = { 'right':0,'left':Math.PI,'up':-Math.PI/2,'down':Math.PI/2 }[pacman.dir];
  const startAngle = angleOffset + mouthOpen*0.4;
  const endAngle = angleOffset - mouthOpen*0.4 + 2*Math.PI;
  ctx.arc(x,y,pacman.radius,startAngle,endAngle,false);
  ctx.lineTo(x,y);
  ctx.closePath();
  ctx.fill();
}

function drawGhosts(){
  ghosts.forEach(g=>{
    const x = g.x*TILE_SIZE + TILE_SIZE/2;
    const y = g.y*TILE_SIZE + TILE_SIZE/2;
    ctx.fillStyle = g.color;
    ctx.beginPath();
    // semicircle head
    ctx.arc(x,y,TILE_SIZE/2,Math.PI,0,false);
    // body rectangle
    ctx.fillRect(x-TILE_SIZE/2, y, TILE_SIZE, TILE_SIZE/2);
    // eyes
    ctx.fillStyle='white';
    ctx.beginPath();
    ctx.arc(x - TILE_SIZE/4, y - TILE_SIZE/4, TILE_SIZE/8, 0, Math.PI*2);
    ctx.arc(x + TILE_SIZE/4, y - TILE_SIZE/4, TILE_SIZE/8, 0, Math.PI*2);
    ctx.fill();
    // pupils
    ctx.fillStyle='black';
    ctx.beginPath();
    ctx.arc(x - TILE_SIZE/4 + 1, y - TILE_SIZE/4, TILE_SIZE/16, 0, Math.PI*2);
    ctx.arc(x + TILE_SIZE/4 + 1, y - TILE_SIZE/4, TILE_SIZE/16, 0, Math.PI*2);
    ctx.fill();
  });
}

function drawOnce(){ ctx.clearRect(0,0,canvas.width,canvas.height); drawMap(); drawPacman(); drawGhosts(); }

/* MOVEMENT */
function canMove(x,y){ return mapData[y] && mapData[y][x] !== 1; }

function movePacman(){
  const nd = pacman.nextDir;
  const nx = pacman.x + (nd==='right'?1:nd==='left'?-1:0);
  const ny = pacman.y + (nd==='down'?1:nd==='up'?-1:0);
  if(canMove(nx,ny)){
    pacman.dir = pacman.nextDir;
    pacman.x = nx; pacman.y = ny;
  } else {
    const cx = pacman.x + (pacman.dir==='right'?1:pacman.dir==='left'?-1:0);
    const cy = pacman.y + (pacman.dir==='down'?1:pacman.dir==='up'?-1:0);
    if(canMove(cx,cy)){ pacman.x = cx; pacman.y = cy; }
  }
  // teleport horizontally
  if(pacman.x < 0) pacman.x = MAP_WIDTH - 1;
  if(pacman.x >= MAP_WIDTH) pacman.x = 0;
}

let ghostMoveSkip = 0;
function moveGhosts(){
  ghostMoveSkip++;
  // slow ghosts on easiest frame cadence; overall speed controlled by GAME_UPDATE_INTERVAL
  if(ghostMoveSkip % 2 !== 0) return;
  ghosts.forEach(g=>{
    const possible=[];
    const moves=[{dx:1,dy:0,dir:'right'},{dx:-1,dy:0,dir:'left'},{dx:0,dy:1,dir:'down'},{dx:0,dy:-1,dir:'up'}];
    moves.forEach(m=>{
      const nx=g.x+m.dx, ny=g.y+m.dy;
      if(canMove(nx,ny)) possible.push(m);
    });
    if(possible.length>0){
      // bias chasing
      possible.sort((a,b)=>{
        const ax = g.x+a.dx-pacman.x, ay=g.y+a.dy-pacman.y;
        const bx = g.x+b.dx-pacman.x, by=g.y+b.dy-pacman.y;
        return Math.hypot(ax,ay) - Math.hypot(bx,by);
      });
      const pick = Math.random() < 0.7 ? possible[0] : possible[Math.floor(Math.random()*possible.length)];
      g.x += pick.dx; g.y += pick.dy; g.dir = pick.dir;
    }
  });
}

/* COLLISIONS & SCORE */
function checkCollision(){
  if(mapData[pacman.y][pacman.x] === 2){
    mapData[pacman.y][pacman.x] = 0;
    score += 10;
    if(score > 3000) score = 3000;
    document.getElementById('current-score-display').textContent = score;
    spawnSparkle(pacman.x, pacman.y);
    // coin sound
    try{ document.getElementById('sndCoin').currentTime=0; document.getElementById('sndCoin').play(); } catch(e){}
  }
  // ghosts collision
  for(const g of ghosts){
    if(g.x === pacman.x && g.y === pacman.y){
      triggerEnd(false); return;
    }
  }
  const dotsRemaining = mapData.flat().filter(c=>c===2).length;
  if(dotsRemaining === 0) triggerEnd(true);
}

/* END GAME wrapper to allow visual effects and postMessage */
function triggerEnd(isWin){
  if(!gameRunning) return;
  gameRunning=false;
  cancelAnimationFrame(animationFrameId);
  // shake canvas and show message
  canvas.classList.add('shake');
  setTimeout(()=>canvas.classList.remove('shake'),420);

  const gm = document.getElementById('game-message');
  const msg = isWin ? "SELAMAT! Anda menang dan membersihkan semua hadiah!" : "Misi Gagal! Grinch berhasil mencuri semua hadiah!";
  gm.textContent = msg + " Skor: " + score;
  gm.style.display = 'block';

  // victory overlay & sounds handled in endGame hook later
  // send score to parent for on-chain submit
  if(score > 0 || isWin){
    window.parent.postMessage({ type: 'submitScore', score: score }, '*');
  } else {
    window.parent.postMessage({ type: 'notifyNoScore' }, '*');
  }

  setTimeout(()=>{
    gm.style.display='none';
    window.parent.postMessage({ type: 'showLeaderboard' }, '*');
  }, 4000);
}

/* GAME LOOP */
let lastTick=0;
function gameLoop(timestamp){
  if(!gameRunning) return;
  const dt = timestamp - lastTick;
  lastTick = timestamp;
  // update only on interval
  if(dt >= GAME_UPDATE_INTERVAL){
    movePacman();
    moveGhosts();
    checkCollision();
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap(); drawPacman(); drawGhosts();
  animationFrameId = requestAnimationFrame(gameLoop);
}

/* DRAW sparkle */
function spawnSparkle(gridX, gridY){
  const el=document.createElement('div');
  el.className='coin-sparkle';
  // position relative to viewport: compute canvas rect
  const rect = canvas.getBoundingClientRect();
  const left = rect.left + gridX * TILE_SIZE + TILE_SIZE/2 - 5; // center minus half sparkle
  const top  = rect.top + gridY * TILE_SIZE + TILE_SIZE/2 - 5;
  el.style.left = left + 'px';
  el.style.top  = top + 'px';
  document.body.appendChild(el);
  setTimeout(()=>el.remove(),700);
}

/* -------------------------
   Visual & audio hooks
   ------------------------- */
const bgm = document.getElementById('bgm');
const sndCoin = document.getElementById('sndCoin');
const sndWin = document.getElementById('sndWin');
const sndLose = document.getElementById('sndLose');
const victoryOverlay = document.getElementById('victoryOverlay');

/* Hook into triggerEnd to play sounds & overlay */
const originalTriggerEnd = triggerEnd;
function endGameHook(isWin){
  // stop bgm
  try{ bgm.pause(); bgm.currentTime = 0; } catch(e){}
  if(isWin){
    try{ sndWin.play(); }catch(e){}
    victoryOverlay.style.display='flex';
    setTimeout(()=>victoryOverlay.style.display='none',3500);
  } else {
    try{ sndLose.play(); }catch(e){}
  }
  originalTriggerEnd(isWin);
}
triggerEnd = endGameHook;

/* -------------------------
   Level system & countdown
   ------------------------- */
const levelPanel = document.getElementById('levelPanel');
const countdownEl = document.getElementById('countdown');

function setLevel(lvl){
  if(lvl === 'easy') GAME_UPDATE_INTERVAL = 220;
  if(lvl === 'normal') GAME_UPDATE_INTERVAL = 150;
  if(lvl === 'hard') GAME_UPDATE_INTERVAL = 95;
  levelPanel.style.display='none';
  // start countdown then game
  startCountdownThenStart();
}

function startCountdownThenStart(){
  resetMapData(); // ensure fresh
  countdownEl.style.display='flex';
  let n = 3;
  countdownEl.textContent = n;
  const timer = setInterval(()=>{
    n--;
    if(n === 0){ countdownEl.textContent = 'GO!'; }
    else if(n < 0){ clearInterval(timer); countdownEl.style.display='none'; startGameLoop(); }
    else countdownEl.textContent = n;
  },1000);
}

function startGameLoop(){
  // start bgm
  try{ bgm.volume = 0.35; bgm.play(); }catch(e){}
  gameRunning = true;
  lastTick = performance.now();
  animationFrameId = requestAnimationFrame(gameLoop);
}

/* -------------------------
   Parent communication (pay + fee)
   ------------------------- */
window.addEventListener('message', (ev)=>{
  const d = ev.data || {};

  if (d.type === 'paySuccess') {
    startCountdownAndPlay();
  }

  if (d.type === 'startFee') {
    const gm = document.getElementById('game-message');
    gm.textContent = `Fee to start: ${d.feeEth} SOMI`;
    gm.style.display = 'block';
    setTimeout(()=>gm.style.display='none',4000);
  }
});

/* request fee once */
window.parent.postMessage({ type:'requestStartFee' }, '*');

/* -------------------------
   Mobile & keyboard controls
   ------------------------- */
document.querySelectorAll('#mobileControls button').forEach(b=>{
  b.addEventListener('touchstart', (e)=>{ e.preventDefault(); pacman.nextDir = b.getAttribute('data-dir'); });
  b.addEventListener('mousedown', (e)=>{ e.preventDefault(); pacman.nextDir = b.getAttribute('data-dir'); });
});
window.addEventListener('keydown',(e)=>{
  if(e.key === 'ArrowUp') pacman.nextDir='up';
  if(e.key === 'ArrowDown') pacman.nextDir='down';
  if(e.key === 'ArrowLeft') pacman.nextDir='left';
  if(e.key === 'ArrowRight') pacman.nextDir='right';
});

/* -------------------------
   Snow effect
   ------------------------- */
setInterval(()=>{ const s=document.createElement('div'); s.className='snow'; s.innerText='‚ùÑ'; s.style.left=Math.random()*100 + 'vw'; s.style.fontSize=(8+Math.random()*18)+'px'; s.style.animationDuration=(3+Math.random()*6)+'s'; document.body.appendChild(s); setTimeout(()=>s.remove(),9000); },140);

/* -------------------------
   INITIALIZE
   ------------------------- */
resetGame();

/* -------------------------
   Auto fallback: If parent not present and you want to test:
   (uncomment for local testing)
*/
// setTimeout(()=>{ /* simulate paySuccess for dev testing */ /* levelPanel.style.display='flex'; */ },1000);

</script>

</body>
</html>
