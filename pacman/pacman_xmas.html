<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pacman XMAS - Santa vs Reindeer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  canvas { background:#000; display:block; margin:0 auto; }
  #game-message { color:#fff; text-align:center; margin-top:10px; }
  #restart-button { display:none; margin:10px auto; }
  #mobileControls { display:flex; justify-content:center; gap:10px; margin-top:10px; }
  #mobileControls button { padding:10px 14px; border-radius:8px; border:none; background:#16a34a; color:#fff; font-weight:bold; }
</style>
</head>
<body>
  <div id="gameWrapper">
    <div id="ui">Score: <span id="current-score-display">0</span></div>
    <button id="restart-button" onclick="handleGameRestart()">Restart Game</button>
    <div id="game-message"></div>
    <canvas id="pacman-canvas"></canvas>
    <div id="mobileControls">
      <button onclick="handleGameInput('left')">◀</button>
      <button onclick="handleGameInput('up')">▲</button>
      <button onclick="handleGameInput('down')">▼</button>
      <button onclick="handleGameInput('right')">▶</button>
    </div>
  </div>

<script>
(() => {
const TRUSTED_ORIGIN = "https://pacman-somniaxmasv1.vercel.app"; // jika tidak dipakai postMessage, biarkan saja
const TILE = 20;
const MOVE_INTERVAL = 240;

const canvas = document.getElementById("pacman-canvas");
const ctx = canvas ? canvas.getContext("2d") : null;
if (!ctx) return;

/* ================== MAP ================== */
const GAME_MAP = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,2,1],
[1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1],
[1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],
[0,0,0,0,1,2,1,0,0,0,0,0,0,1,2,1,0,0,0,0],
[1,1,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1],
[1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1],
[1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];
const MAP_W = GAME_MAP[0].length;
const MAP_H = GAME_MAP.length;

canvas.width = MAP_W * TILE;
canvas.height = MAP_H * TILE;

/* utility rounded rect */
function roundRect(ctx, x, y, w, h, r) {
  if (r === undefined) r = 6;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

/* ========== AUDIO SYSTEM ========== */
let audioCtx = null;
const DOT_SOUND_VOLUME = 0.5;
let dotPool = [];
const DOT_POOL_SIZE = 5;

function initAudioPool() {
  if (audioCtx) return;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    for (let i = 0; i < DOT_POOL_SIZE; i++) {
      dotPool.push({ freq: 500 + i * 20, duration: 0.05 });
    }
  } catch(e) { console.error("AudioContext failed to initialize:", e); }
  document.removeEventListener('touchstart', initAudioPool);
  document.removeEventListener('mousedown', initAudioPool);
}

let dotIndex = 0;
function playDotSound() {
  if (!audioCtx) return;
  dotIndex = (dotIndex + 1) % DOT_POOL_SIZE;
  const sound = dotPool[dotIndex];
  const source = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();
  source.type = 'sine';
  source.frequency.setValueAtTime(sound.freq, audioCtx.currentTime);
  gainNode.gain.setValueAtTime(DOT_SOUND_VOLUME, audioCtx.currentTime);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + sound.duration);
  source.connect(gainNode);
  gainNode.connect(audioCtx.destination);
  source.start();
  source.stop(audioCtx.currentTime + sound.duration);
}
document.addEventListener('touchstart', initAudioPool, { once: true });
document.addEventListener('mousedown', initAudioPool, { once: true });

/* ========== STATE & INIT ========== */
let mapData, pacman, ghosts, score = 0;
let lastMove = 0;
let gameRunning = false;
let ghostActive = false;
let scoreSubmitted = false;
let sessionStartTime = 0;
window.allowLocalPlay = false; // penting: dikontrol dari app.js
let animationFrameId = null;

function resetGame(){
  mapData = GAME_MAP.map(r=>[...r]);
  pacman = {x:1,y:1,dir:"right",next:"right"};
  ghosts = [
    {x:9,y:9,color:"#ff0033", antlerColor:"#964B00", noseColor:"#cc0000"},
    {x:10,y:9,color:"#00b300", antlerColor:"#964B00", noseColor:"#556B2F"},
    {x:8,y:9,color:"#1e90ff", antlerColor:"#964B00", noseColor:"#87CEFA"}
  ];
  score = 0;
  scoreSubmitted = false;
  sessionStartTime = Date.now();
  document.getElementById("current-score-display").textContent = score;
  document.getElementById("game-message").style.display = "none";
  document.getElementById("restart-button").style.display = "none";
  gameRunning = false;
  ghostActive = false;
}

window.handleGameRestart = function() {
  if(!window.allowLocalPlay) {
    const gm = document.getElementById("game-message");
    gm.textContent = "Game not yet active. Please connect/pay.";
    gm.style.display = "block";
    setTimeout(() => gm.style.display = "none", 1500);
    return;
  }
  resetGame();
  startCountdown();
};

function startCountdown() {
  const gm = document.getElementById("game-message");
  let count = 3;
  gm.style.display = "block";
  gm.textContent = "READY " + count;

  if(window.gameStartInterval) clearInterval(window.gameStartInterval);

  window.gameStartInterval = setInterval(()=>{
    count--;
    if(count >= 0) gm.textContent = "READY " + count;
    if(count < 0){
      clearInterval(window.gameStartInterval);
      gm.style.display = "none";
      ghostActive = true;
      gameRunning = true;
      lastMove = performance.now();
      document.getElementById("restart-button").style.display = "block";
    }
  }, 1000);
}

/* ========== DRAWING ========== */
function drawMap(){
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      const t = mapData[y][x];
      if(t===1){
        ctx.fillStyle="#b91c1c";
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        ctx.strokeStyle="rgba(249,250,251,0.6)";
        ctx.lineWidth=1;
        ctx.strokeRect(x*TILE+0.5,y*TILE+0.5,TILE-1,TILE-1);
      } else {
        ctx.fillStyle="#020617";
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        if(t===2){
          ctx.fillStyle="#ffd700";
          ctx.beginPath();
          ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,3,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}
function drawPacman(){
  const wobbleY = Math.sin(Date.now() / 150) * 1.5;
  const px = pacman.x*TILE + TILE/2;
  const py = pacman.y*TILE + TILE/2 + wobbleY;
  const mouth = Math.abs(Math.sin(Date.now()/120))*0.5;
  const angleMap = {right:0,left:Math.PI,up:-Math.PI/2,down:Math.PI/2};
  const angle = angleMap[pacman.dir] || 0;

  ctx.fillStyle="#facc15";
  ctx.beginPath();
  ctx.moveTo(px,py);
  ctx.arc(px,py,TILE/2-2,angle+mouth*0.6,angle-mouth*0.6+Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(px, py + TILE/8, TILE/3.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle="#cc0000";
  ctx.beginPath();
  ctx.moveTo(px - TILE*0.35, py - TILE*0.3);
  ctx.lineTo(px + TILE*0.35, py - TILE*0.3);
  ctx.lineTo(px, py - TILE*0.8);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(px, py - TILE*0.8, 3.5, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.fillRect(px - TILE*0.35, py - TILE*0.3, TILE*0.7, 3);
}

function drawGhosts(){
  ghosts.forEach(g=>{
    const wobbleY = Math.sin(Date.now() / 150 + g.x * 0.5) * 1.5;
    const gx = g.x*TILE + TILE/2;
    const gy = g.y*TILE + TILE/2 + wobbleY;
    const size = TILE * 0.45;
    const headWobble = Math.sin(Date.now() / 200) * 1;

    ctx.save();
    ctx.shadowBlur = 8;
    ctx.shadowColor = g.color;
    ctx.fillStyle = g.color;
    roundRect(ctx, gx - size, gy - size, size * 2, size * 2, 6);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.arc(gx - TILE*0.15, gy - TILE*0.15, 2, 0, Math.PI*2);
    ctx.arc(gx + TILE*0.15, gy - TILE*0.15, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle="black";
    ctx.beginPath();
    ctx.arc(gx - TILE*0.15 + headWobble, gy - TILE*0.15, 1, 0, Math.PI*2);
    ctx.arc(gx + TILE*0.15 + headWobble, gy - TILE*0.15, 1, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle=g.noseColor;
    ctx.beginPath();
    ctx.arc(gx, gy + TILE*0.25, 3, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle=g.antlerColor;
    ctx.fillRect(gx - TILE*0.35, gy - TILE*0.4, 2, 5);
    ctx.fillRect(gx - TILE*0.35 + 2, gy - TILE*0.4 - 2, 5, 2);
    ctx.fillRect(gx + TILE*0.35 - 2, gy - TILE*0.4, 2, 5);
    ctx.fillRect(gx + TILE*0.35 - 7, gy - TILE*0.4 - 2, 5, 2);
  });
}
/* ========== END DRAWING ========== */

/* ========== GAME LOGIC ========== */
function canMove(nx, ny){
  // wrap tunnels on row 8 and 9 where zeros exist
  if (ny>=0 && ny<MAP_H && nx>=0 && nx<MAP_W) {
    const t = mapData[ny][nx];
    return t !== 1; // not wall
  }
  return false;
}

function eatDotIfAny(x,y){
  if(mapData[y][x]===2){
    mapData[y][x]=0;
    score+=10;
    document.getElementById("current-score-display").textContent=score;
    playDotSound();
  }
}

function movePacman(){
  let nx=pacman.x, ny=pacman.y;
  if(pacman.next==="left") nx--;
  if(pacman.next==="right") nx++;
  if(pacman.next==="up") ny--;
  if(pacman.next==="down") ny++;

  if(canMove(nx,ny)){
    pacman.x=nx; pacman.y=ny; pacman.dir=pacman.next;
    eatDotIfAny(pacman.x,pacman.y);
  } else {
    // try current direction
    let dx=0, dy=0;
    if(pacman.dir==="left") dx=-1;
    if(pacman.dir==="right") dx=1;
    if(pacman.dir==="up") dy=-1;
    if(pacman.dir==="down") dy=1;
    nx=pacman.x+dx; ny=pacman.y+dy;
    if(canMove(nx,ny)){
      pacman.x=nx; pacman.y=ny;
      eatDotIfAny(pacman.x,pacman.y);
    }
  }
}

function moveGhosts(){
  ghosts.forEach(g=>{
    // simple random walker that avoids walls
    const dirs = [
      {d:"left",dx:-1,dy:0},
      {d:"right",dx:1,dy:0},
      {d:"up",dx:0,dy:-1},
      {d:"down",dx:0,dy:1}
    ];
    const pick = dirs[Math.floor(Math.random()*dirs.length)];
    const nx=g.x+pick.dx, ny=g.y+pick.dy;
    if(canMove(nx,ny)){
      g.x=nx; g.y=ny;
    }
  });
}

function checkCollision(){
  for(const g of ghosts){
    if(g.x===pacman.x && g.y===pacman.y){
      gameOver();
      return;
    }
  }
  // win condition: no dots left
  let anyDot=false;
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      if(mapData[y][x]===2){ anyDot=true; break; }
    }
    if(anyDot) break;
  }
  if(!anyDot){ gameOver(true); }
}

function gameOver(won=false){
  gameRunning=false;
  ghostActive=false;
  const gm=document.getElementById("game-message");
  gm.style.display="block";
  gm.textContent = won ? "You win! Submit score..." : "Game Over! Submit score...";
  // trigger parent to submit score (ke app.js) — atau biarkan app.js memanggil ini via DOM
  try {
    // jika ingin kirim via postMessage (opsional)
    window.parent.postMessage({ type:"submitScore", score }, "*");
  } catch(e){}
}

/* ========== INPUT ========== */
window.handleGameInput = function(direction){
  if(!window.allowLocalPlay || !gameRunning){
    const gm=document.getElementById("game-message");
    gm.textContent="Please connect / pay to start the game.";
    gm.style.display="block";
    setTimeout(()=>gm.style.display="none",1200);
    return;
  }
  const d = (direction||"").toLowerCase();
  if(["left","right","up","down"].includes(d)){
    pacman.next=d;
  }
};

document.addEventListener("keydown",(e)=>{
  if(!window.allowLocalPlay || !gameRunning) return;
  const key = e.key.toLowerCase();
  if(key==="arrowleft"||key==="a") pacman.next="left";
  if(key==="arrowright"||key==="d") pacman.next="right";
  if(key==="arrowup"||key==="w") pacman.next="up";
  if(key==="arrowdown"||key==="s") pacman.next="down";
});

/* ========== LOOP ========== */
function update(ts){
  if(!gameRunning) return;
  if(!lastMove) lastMove = ts;
  const elapsed = ts - lastMove;
  if(elapsed >= MOVE_INTERVAL){
    movePacman();
    if(ghostActive) moveGhosts();
    checkCollision();
    lastMove = ts;
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();
  drawPacman();
  drawGhosts();
}

function loop(ts){
  update(ts);
  draw();
  animationFrameId = requestAnimationFrame(loop);
}

/* ========== EXPOSE & INIT ========== */
window.resetGame = resetGame;
window.startCountdown = startCountdown;

document.addEventListener("DOMContentLoaded",()=>{
  resetGame();
  const gm = document.getElementById("game-message");
  gm.textContent="Waiting for payment/connection...";
  gm.style.display="block";
  requestAnimationFrame(loop);
});
})();
</script>
</body>
</html>
