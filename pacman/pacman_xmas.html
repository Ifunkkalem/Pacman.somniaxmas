<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pacman XMAS - Santa vs Reindeer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  /* Layout CSS dari versi stabil Anda (Tidak Berubah) */
  html,body{
    margin:0;
    background:#000;
    height:100%;
    min-height:100vh;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    font-family:Arial, Helvetica, sans-serif;
    padding:12px;
    box-sizing:border-box;
  }

  /* Penting: Pastikan ukuran wrapper sesuai dengan yang di-set di index.html */
  #gameWrapper{
    width: calc(20 * 20px + 40px); 
    max-width: 92vw;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:12px;
  }

  canvas{
    background:#020617;
    border-radius:10px;
    display:block;
    box-shadow: 0 8px 24px rgba(0,0,0,0.6);
    image-rendering: optimizeSpeed;
  }

  #ui{position:relative;color:#fff;z-index:2;align-self:flex-start}
  #game-message{
    color:white;
    background:rgba(0,0,0,.6);
    padding:6px 10px;
    border-radius:8px;
    display:none;
    z-index:12;
    text-align: center;
  }

  /* Mobile D-PAD */
  #mobileControls{
    position:relative;
    margin-top:6px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:8px;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  
  #mobileControls button{
    width: 70px; 
    height: 70px; 
    border-radius:10px;border:0;
    background:linear-gradient(90deg,#cc0000,#16a34a);color:#fff;font-size:22px;
    display:inline-flex;align-items:center;justify-content:center;
    box-shadow:0 4px rgba(0,0,0,0.4);
    touch-action: manipulation;
  }
  .dpad-row{display:flex;align-items:center;gap:8px}
  .center-filler{width: 70px; height: 70px;}
  
  /* Desktop: hide mobile pad, allow centering large canvas */
  @media(min-width:900px){
    body{align-items:center}
    #gameWrapper{max-width:760px}
    #mobileControls{display:none}
  }

  /* ensure small screens canvas fits and leaves room for pad */
  @media(max-width:480px){
    #gameWrapper{ width: 90vw; }
  }
</style>
</head>

<body>
  <div id="gameWrapper">
    <div id="ui">Score: <span id="current-score-display">0</span></div>
    <div id="game-message"></div> <canvas id="pacman-canvas" aria-label="Pacman XMAS game"></canvas>
    
    <div id="mobileControls" aria-hidden="false" style="display: none;"> <button data-dir="up" id="btn-up">↑</button>
      <div class="dpad-row">
        <button data-dir="left" id="btn-left">←</button>
        <div class="center-filler" aria-hidden="true"></div>
        <button data-dir="right" id="btn-right">→</button>
      </div>
      <button data-dir="down" id="btn-down">↓</button>
    </div>
  </div>

<script>
(() => {
const canvas = document.getElementById("pacman-canvas");
const ctx = canvas.getContext("2d");
const TILE = 20;

/* ================== MAP ================== */
const GAME_MAP = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,2,1],
[1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1],
[1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],
[0,0,0,0,1,2,1,0,0,0,0,0,0,1,2,1,0,0,0,0],
[1,1,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1],
[1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1],
[1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const MAP_W = GAME_MAP[0].length;
const MAP_H = GAME_MAP.length;

canvas.width = MAP_W * TILE;
canvas.height = MAP_H * TILE;

// Fungsi roundRect (Tidak Berubah)
function roundRect(ctx, x, y, w, h, r) {
  if (r === undefined) r = 6;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

/* ========== STATE ========== */
let mapData, pacman, ghosts, score = 0;
let gameRunning = false;
let ghostActive = false;
let allowLocalPlay = false; 
let gameTickInterval = null; // Didefinisikan di sini

/* ========== INIT ========== */
function resetGame(){
  mapData = GAME_MAP.map(r=>[...r]);
  pacman = {x:1,y:1,dir:"right",next:"right"};
  ghosts = [
    {x:9,y:9,color:"#ff0033", antlerColor:"#964B00", noseColor:"#cc0000"},
    {x:10,y:9,color:"#00b300", antlerColor:"#964B00", noseColor:"#556B2F"},
    {x:8,y:9,color:"#1e90ff", antlerColor:"#964B00", noseColor:"#87CEFA"}
  ];
  score = 0;
  document.getElementById("current-score-display").textContent = score;
  
  gameRunning = false;
  ghostActive = false;
  
  // FIX: Clear interval jika ada
  if (gameTickInterval) clearInterval(gameTickInterval); 

  // FIX: Hapus semua logic pesan/display di sini. Akan diatur oleh requestInitialState.
  document.getElementById("game-message").style.display = "none";
  const mobileControls = document.getElementById("mobileControls");
  if (mobileControls) mobileControls.style.display = "none";
}

/* ========== DRAWING (Santa & Reindeer visuals) ========== */
function drawMap(){
  // ... (Fungsi drawMap tetap sama)
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      const t = mapData[y][x];
      if(t===1){
        ctx.fillStyle="#b91c1c";
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        ctx.strokeStyle="rgba(249,250,251,0.6)";
        ctx.lineWidth=1;
        ctx.strokeRect(x*TILE+0.5,y*TILE+0.5,TILE-1,TILE-1);
      } else {
        ctx.fillStyle="#020617";
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        if(t===2){
          ctx.fillStyle="#ffd700";
          ctx.beginPath();
          ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,3,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}

function drawPacman(){
  // ... (Fungsi drawPacman tetap sama)
  const wobbleY = Math.sin(Date.now() / 150) * 1.5;
  const x = pacman.x*TILE + TILE/2;
  const y = pacman.y*TILE + TILE/2 + wobbleY;
  const mouth = Math.abs(Math.sin(Date.now()/120))*0.5;
  const angle = {right:0,left:Math.PI,up:-Math.PI/2,down:Math.PI/2}[pacman.dir];

  ctx.fillStyle="#facc15";
  ctx.beginPath();
  ctx.moveTo(x,y);
  ctx.arc(x,y,TILE/2-2,angle+mouth*0.6,angle-mouth*0.6+Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(x, y + TILE/8, TILE/3.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle="#cc0000";
  ctx.beginPath();
  ctx.moveTo(x - TILE*0.35, y - TILE*0.3);
  ctx.lineTo(x + TILE*0.35, y - TILE*0.3);
  ctx.lineTo(x, y - TILE*0.8);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(x, y - TILE*0.8, 3.5, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.fillRect(x - TILE*0.35, y - TILE*0.3, TILE*0.7, 3);
}

function drawGhosts(){
  // ... (Fungsi drawGhosts tetap sama)
  ghosts.forEach(g=>{
    const wobbleY = Math.sin(Date.now() / 150 + g.x * 0.5) * 1.5;
    const x = g.x*TILE + TILE/2;
    const y = g.y*TILE + TILE/2 + wobbleY;
    const size = TILE * 0.45;
    const headWobble = Math.sin(Date.now() / 200) * 1;

    ctx.save();
    ctx.shadowBlur = 8;
    ctx.shadowColor = g.color;
    ctx.fillStyle = g.color;
    roundRect(ctx, x - size, y - size, size * 2, size * 2, 6);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.arc(x - TILE*0.15, y - TILE*0.15, 2, 0, Math.PI*2);
    ctx.arc(x + TILE*0.15, y - TILE*0.15, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle="black";
    ctx.beginPath();
    ctx.arc(x - TILE*0.15 + headWobble, y - TILE*0.15, 1, 0, Math.PI*2);
    ctx.arc(x + TILE*0.15 + headWobble, y - TILE*0.15, 1, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle=g.noseColor;
    ctx.beginPath();
    ctx.arc(x, y + TILE*0.25, 3, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle=g.antlerColor;
    ctx.fillRect(x - TILE*0.35, y - TILE*0.4, 2, 5);
    ctx.fillRect(x - TILE*0.35 + 2, y - TILE*0.4 - 2, 5, 2);
    ctx.fillRect(x + TILE*0.35 - 2, y - TILE*0.4, 2, 5);
    ctx.fillRect(x + TILE*0.35 - 7, y - TILE*0.4 - 2, 5, 2);
  });
}

/* ========== MOVEMENT & COLLISIONS ========== */
function canMove(x,y){ 
    if (y >= 8 && y <= 9 && x === -1) return true;
    if (y >= 8 && y <= 9 && x === MAP_W) return true;
    return mapData[y] && mapData[y][x] !== 1; 
}

function movePacman(){
  let nx = pacman.x, ny = pacman.y;
  const d = pacman.next;
  
  nx = pacman.x + (d==="right"?1:d==="left"?-1:0);
  ny = pacman.y + (d==="down"?1:d==="up"?-1:0);
  
  if (nx < 0 && pacman.y >= 8 && pacman.y <= 9) { pacman.x = MAP_W - 1; pacman.dir = d; return; }
  if (nx >= MAP_W && pacman.y >= 8 && pacman.y <= 9) { pacman.x = 0; pacman.dir = d; return; }

  if(canMove(nx,ny)){
    pacman.x = nx;
    pacman.y = ny;
    pacman.dir = d;
  } else {
    const cx = pacman.x + (pacman.dir==="right"?1:pacman.dir==="left"?-1:0);
    const cy = pacman.y + (pacman.dir==="down"?1:pacman.dir==="up"?-1:0);
    if(canMove(cx,cy)){
        pacman.x = cx;
        pacman.y = cy;
    }
  }
}

function moveGhosts(){
  if(!ghostActive) return;
  ghosts.forEach(g=>{
    const dx = pacman.x - g.x;
    const dy = pacman.y - g.y;
    let newX = g.x, newY = g.y;
    
    if (Math.random() < 0.7) {
        if (Math.abs(dx) > Math.abs(dy)) {
            newX = g.x + (dx > 0 ? 1 : -1);
        } else {
            newY = g.y + (dy > 0 ? 1 : -1);
        }
    } else {
        const d = [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)];
        newX = g.x + d[0];
        newY = g.y + d[1];
    }

    if(canMove(newX, newY)){ 
        g.x = newX; g.y = newY; 
    }
  });
}

// FIX: Game logic diatur oleh interval (game tick)
function gameTick() {
    if (!gameRunning) return;
    
    movePacman();
    moveGhosts();
    checkCollision();
}

function checkCollision(){
  // Check Dot Eaten
  if(mapData[pacman.y][pacman.x] === 2){
    mapData[pacman.y][pacman.x] = 0;
    score += 10;
    document.getElementById("current-score-display").textContent = score;
    // FIX: Tidak perlu postMessage untuk setiap dotEaten
  }

  // Check Ghost Collision
  for(const g of ghosts){
    if(g.x === pacman.x && g.y === pacman.y){
      gameOver(false); // Game Over (Lost)
      return;
    }
  }

  // Check Win Condition
  let win = true;
  for(let y=0;y<mapData.length;y++){
    for(let x=0;x<mapData[y].length;x++){
      if(mapData[y][x] === 2) { win = false; break; }
    }
    if(!win) break;
  }
  if(win){
    gameOver(true); // Game Over (Win)
  }
}

function gameOver(isWin){
  if (!gameRunning) return; 
  gameRunning = false;
  ghostActive = false;
  
  // Hentikan Game Tick saat Game Over
  if (gameTickInterval) clearInterval(gameTickInterval);
  
  const gm = document.getElementById("game-message");
  gm.textContent = isWin ? "YOU WIN! Score: " + score + ". Submitting..." : "GAME OVER! Score: " + score + ". Submitting...";
  gm.style.display = "block";
  
  // SINYAL KRITIS: Kirim score ke Parent (index.html)
  parent.postMessage({ type: "submitScore", score }, "*"); 
}

/* ========== COUNTDOWN helper ========== */
function startCountdownAndPlay(){
  const gm = document.getElementById("game-message");
  let count = 3;
  gm.style.display = "block";
  gm.textContent = "READY " + count;

  const t = setInterval(()=>{
    count--;
    if(count >= 0) gm.textContent = "READY " + count;
    if(count < 0){
      clearInterval(t);
      gm.style.display = "none";
      ghostActive = true;
      gameRunning = true;
      
      // FIX PENTING: Set interval game logic 
      // 240ms adalah kecepatan klasik Pacman (sekitar 4x per detik)
      gameTickInterval = setInterval(gameTick, 240); 
    }
  }, 1000);
}

/* ========== LOOP (Hanya untuk Rendering) ========== */
function loop(ts){
  // Hanya Rendering
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();
  drawPacman();
  drawGhosts();
  requestAnimationFrame(loop);
}

/* ========== MESSAGES & CONTROLS ========== */

// FIX: Fungsi baru untuk meminta status awal dari parent
function requestInitialState() {
  window.parent.postMessage({ type: 'requestGameStatus' }, '*');
}

// HANDLER PESAN UTAMA DARI PARENT (index.html)
window.addEventListener("message", (e) => {
  const d = e.data || {};
  if(!d || typeof d !== 'object') return;

  if(d.type === "paySuccess"){
    // Parent mengonfirmasi pembayaran/start
    allowLocalPlay = true;
    resetGame();
    startCountdownAndPlay();
  }
  
  // FIX: Tangani respons status dari parent
  if (d.type === "gameStatusResponse") {
    allowLocalPlay = d.allowLocalPlay;
    
    const gm = document.getElementById("game-message");
    const mobileControls = document.getElementById("mobileControls");

    if (allowLocalPlay) {
      gm.textContent = "GAME READY. Press arrow key to begin.";
      if (mobileControls) mobileControls.style.display = "flex";
    } else {
      gm.textContent = "CONNECT WALLET & PAY TO START";
      if (mobileControls) mobileControls.style.display = "none";
    }
    gm.style.display = "block";
  }

  if(d.type === "forceReset"){
    if (gameTickInterval) clearInterval(gameTickInterval);
    resetGame();
  }
  if(d.type === "waitingForTx"){
    document.getElementById("game-message").textContent = "Transaction sent. Waiting for confirmation...";
    document.getElementById("game-message").style.display = "block";
  }
});

/* Fungsi untuk mengatur input internal D-Pad/Keyboard */
function handleGameInput(direction){
  if(direction && typeof direction === "string"){
    pacman.next = direction.toLowerCase();
    
    // Auto-start game jika user menekan tombol pertama kali
    if (allowLocalPlay && !gameRunning) {
        startCountdownAndPlay();
    }
  }
}

/* INPUT HANDLERS - (Tetap Sama) */
document.querySelectorAll("#mobileControls button").forEach(btn=>{
  const dir = btn.getAttribute("data-dir");
  const start = (ev) => {
    ev.preventDefault();
    btn.style.transform = "translateY(2px)";
    
    if(!allowLocalPlay){
      const gm = document.getElementById("game-message");
      gm.textContent = "Please connect / pay the fee on the menu to start!";
      gm.style.display = "block";
      setTimeout(()=> gm.style.display = "none", 1200);
      return;
    }
    
    handleGameInput(dir); 
  };
  const end = (ev) => {
    ev.preventDefault();
    btn.style.transform = "";
  };
  btn.addEventListener("touchstart", start, {passive:false});
  btn.addEventListener("mousedown", start);
  btn.addEventListener("touchend", end);
  btn.addEventListener("mouseup", end);
});

/* keyboard arrows: same gating */
window.addEventListener("keydown", (e)=>{
  if(e.key.includes("Arrow")){
    const dir = e.key.replace("Arrow","").toLowerCase();
    
    if(!allowLocalPlay){
      const gm = document.getElementById("game-message");
      gm.textContent = "Please connect / pay the fee on the menu to start!";
      gm.style.display = "block";
      setTimeout(()=> gm.style.display = "none", 1200);
      return;
    }
    
    handleGameInput(dir);
  }
});

/* ========== STARTUP ========== */
document.addEventListener("DOMContentLoaded", () => {
    resetGame();
    // FIX: Minta status awal dari parent
    requestInitialState(); 
});

requestAnimationFrame(loop);

})();
</script>
</body>
</html>

