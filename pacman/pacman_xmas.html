<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Pacman Natal</title>
<style>
html,body{height:100%;margin:0;background:#000;display:flex;align-items:center;justify-content:center;font-family:Trebuchet MS}
#ui{position:fixed;top:10px;left:10px;color:#fff;z-index:9}
#game-message{position:fixed;top:8px;right:8px;color:#fff;z-index:9}
canvas{background:#071024;border-radius:6px}

/* D-PAD */
#mobileControls{
  position:fixed;
  bottom:12px;
  left:50%;
  transform:translateX(-50%);
  display:flex;
  flex-direction: column;
  align-items: center;
  z-index:9;
}
#mobileControls button{
  width:60px;height:60px;
  margin:4px;
  font-size:24px;
  border-radius:8px;
  border:none;
  background: linear-gradient(90deg, #cc0000, #16a34a);
  color:#fff;
}
.dpad-row{display:flex;width:100%;justify-content:space-between}
.center-filler{width:60px;height:60px}
</style>
</head>
<body>

<div id="ui">
  <div id="current-score-display">0</div>
  <div id="game-message" style="display:none;background:rgba(0,0,0,0.6);padding:6px;border-radius:6px;margin-top:6px"></div>
</div>

<canvas id="pacman-canvas"></canvas>

<div id="mobileControls">
  <button data-dir="up">↑</button> 
  <div class="dpad-row">
    <button data-dir="left">←</button>
    <div class="center-filler"></div>
    <button data-dir="right">→</button>
  </div>
  <button data-dir="down">↓</button>
</div>

<!-- AUDIO FILES (pastikan ada di folder assets/) -->
<audio id="bgm" src="assets/music_background.mp3" loop></audio>
<audio id="sfxEat" src="assets/sfx_dot_eat.mp3"></audio>
<audio id="sfxStart" src="assets/sfx_start.mp3"></audio>

<script>
(function(){

/* ---------- CANVAS / MAP ---------- */
const canvas = document.getElementById('pacman-canvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 20;

/* MAP ASLI (TIDAK DIUBAH) */
const GAME_MAP = [
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
 [1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
 [1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
 [1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
 [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
 [1,2,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,2,1],
 [1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1],
 [1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],
 [0,0,0,0,1,2,1,0,0,0,0,0,0,1,2,1,0,0,0,0],
 [1,1,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,1,1],
 [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
 [1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1],
 [1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1],
 [1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1],
 [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
 [1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
 [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
 [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const MAP_WIDTH = GAME_MAP[0].length;
const MAP_HEIGHT = GAME_MAP.length;
canvas.width = MAP_WIDTH * TILE_SIZE;
canvas.height = MAP_HEIGHT * TILE_SIZE;

/* ---------- AUDIO (KONSISTEN) ---------- */
const bgm = document.getElementById("bgm");
const sfxEat = document.getElementById("sfxEat");
const sfxStart = document.getElementById("sfxStart");

let audioUnlocked = false;
bgm.volume = 0.5;
sfxEat.volume = 0.8;
sfxStart.volume = 0.9;

/* Most browsers block autoplay. Play bgm on first user gesture. */
function unlockAudio(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  bgm.play().catch(()=>{});
}

/* also attach a pointerdown as fallback to ensure play attempt on first gesture */
function enableBgmOnGesture(){
  function once(){ unlockAudio(); window.removeEventListener('pointerdown', once); }
  window.addEventListener('pointerdown', once);
}
enableBgmOnGesture();

/* ---------- GAME STATE ---------- */
let pacman, ghosts, score, mapData;
let gameRunning = false;   // START behavior preserved: startGame() sets this
let ghostActive = false;   // ghosts won't move until countdown completes
let lastMove = 0;
let hasInput = false;
const MOVE_INTERVAL = 240;

/* ---------- INIT / RESET ---------- */
function resetMapData(){
  mapData = GAME_MAP.map(r=>[...r]);
  pacman = { x:1, y:1, dir:'right', nextDir:'right', radius:TILE_SIZE/2.5 };
  ghosts = [
    { x:9,y:9,color:'#cc0000' },
    { x:10,y:9,color:'#16a34a' },
    { x:8,y:9,color:'#2563eb' }
  ];
  score = 0;
  hasInput = false;
  ghostActive = false;
}

function resetGame(){
  resetMapData();
  document.getElementById('current-score-display').textContent = score;
  document.getElementById('game-message').style.display = 'none';
  gameRunning = false; // preserve original
  lastMove = 0;
  drawOnce(); // ensure visible immediately
}

/* ---------- DRAWING ---------- */
function drawMap(){
  for(let y=0;y<MAP_HEIGHT;y++){
    for(let x=0;x<MAP_WIDTH;x++){
      const t = mapData[y][x];
      if(t===1){
        ctx.fillStyle = '#cc0000';
        ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
      } else {
        ctx.fillStyle = '#1a2c42';
        ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
        if(t===2){
          ctx.fillStyle = '#facc15';
          ctx.beginPath();
          ctx.arc(x*TILE_SIZE + TILE_SIZE/2, y*TILE_SIZE + TILE_SIZE/2, 3, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}

function drawPacman() {
  const x = pacman.x * TILE_SIZE + TILE_SIZE / 2;
  const y = pacman.y * TILE_SIZE + TILE_SIZE / 2;
  ctx.fillStyle = '#facc15';
  ctx.beginPath();

  const mouthOpen = Math.abs(Math.sin(Date.now() / 100));
  const angleOffset = { 'right': 0, 'left': Math.PI, 'up': -Math.PI / 2, 'down': Math.PI / 2 }[pacman.dir];
  const startAngle = angleOffset + mouthOpen * 0.4;
  const endAngle = angleOffset - mouthOpen * 0.4 + 2 * Math.PI;

  ctx.arc(x, y, pacman.radius, startAngle, endAngle, false);
  ctx.lineTo(x, y);
  ctx.closePath();
  ctx.fill();

  // Santa hat (simple)
  ctx.fillStyle = '#cc0000';
  ctx.beginPath();
  ctx.moveTo(x - pacman.radius*0.6, y - pacman.radius);
  ctx.lineTo(x + pacman.radius*0.6, y - pacman.radius);
  ctx.lineTo(x, y - pacman.radius*1.6);
  ctx.closePath();
  ctx.fill();
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(x, y - pacman.radius*1.6, 3, 0, Math.PI*2);
  ctx.fill();
}

function drawGhosts() {
  ghosts.forEach(ghost => {
    const x = ghost.x * TILE_SIZE + TILE_SIZE / 2;
    const y = ghost.y * TILE_SIZE + TILE_SIZE / 2;

    ctx.save();
    ctx.shadowColor = ghost.color;
    ctx.shadowBlur = 12;

    ctx.fillStyle = ghost.color;
    ctx.beginPath();
    ctx.arc(x, y, TILE_SIZE/2, Math.PI, 0, false);
    ctx.rect(x - TILE_SIZE/2, y, TILE_SIZE, TILE_SIZE/2);
    ctx.closePath();
    ctx.fill();

    // eyes
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - TILE_SIZE/4, y - TILE_SIZE/6, TILE_SIZE/8, 0, Math.PI*2);
    ctx.arc(x + TILE_SIZE/4, y - TILE_SIZE/6, TILE_SIZE/8, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(x - TILE_SIZE/4 + 1, y - TILE_SIZE/6, TILE_SIZE/16, 0, Math.PI*2);
    ctx.arc(x + TILE_SIZE/4 + 1, y - TILE_SIZE/6, TILE_SIZE/16, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  });
}

function drawOnce(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();
  drawPacman();
  drawGhosts();
}

/* ---------- MOVEMENT ---------- */
function canMove(x,y){
  return mapData[y] !== undefined && mapData[y][x] !== 1;
}

function movePacman(){
  // Pacman allowed to move if there's been any input (per your earlier requirement)
  if(!hasInput) return;
  const d = pacman.nextDir;
  const nx = pacman.x + (d==="right"?1:d==="left"?-1:0);
  const ny = pacman.y + (d==="down"?1:d==="up"?-1:0);
  if(canMove(nx,ny)){
    pacman.x = nx;
    pacman.y = ny;
    pacman.dir = d;
  }
}

function moveGhosts(){
  if(!ghostActive) return;
  ghosts.forEach(g=>{
    const d = [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)];
    const nx = g.x + d[0], ny = g.y + d[1];
    if(canMove(nx,ny)){ g.x = nx; g.y = ny; }
  });
}

/* ---------- COLLISIONS, SFX, WIN ---------- */
function checkWin(){
  for(let y=0;y<MAP_HEIGHT;y++){
    for(let x=0;x<MAP_WIDTH;x++){
      if(mapData[y][x] === 2) return false;
    }
  }
  return true;
}

function checkCollision(){
  if(mapData[pacman.y][pacman.x] === 2){
    mapData[pacman.y][pacman.x] = 0;
    score += 10;
    try{ sfxEat.currentTime = 0; sfxEat.play().catch(()=>{}); }catch(e){}
    document.getElementById('current-score-display').textContent = score;
  }

  // any ghost kills pacman
  for(const g of ghosts){
    if(g.x === pacman.x && g.y === pacman.y){
      endGame();
      return;
    }
  }

  // check win
  if(checkWin()){
    gameRunning = false;
    const gm = document.getElementById('game-message');
    gm.textContent = 'YOU WIN!';
    gm.style.display = 'block';
    try{ window.parent.postMessage({ type:'submitScore', score: score }, "*"); }catch(e){}
  }
}

/* ---------- GAME LOOP ---------- */
function gameLoop(ts){
  if(gameRunning){
    if(ts - lastMove > MOVE_INTERVAL){
      movePacman();
      moveGhosts();
      checkCollision();
      lastMove = ts;
    }
  }
  drawOnce();
  requestAnimationFrame(gameLoop);
}

/* ---------- START / COUNTDOWN ---------- */
function startGame(){
  if(gameRunning) return;

  unlockAudio(); // ensure audio available if start triggered programmatically

  // attempt to play start SFX
  try{ sfxStart.currentTime = 0; sfxStart.play().catch(()=>{}); }catch(e){}

  // show countdown, keep ghosts inactive until countdown done
  ghostActive = false;
  const gm = document.getElementById('game-message');
  let count = 3;
  gm.style.display = 'block';
  gm.textContent = 'READY ' + count;
  const t = setInterval(()=>{
    count--;
    if(count >= 0) gm.textContent = 'READY ' + count;
    if(count < 0){
      clearInterval(t);
      gm.style.display = 'none';
      ghostActive = true;
      gameRunning = true;
      lastMove = performance.now();
    }
  }, 1000);
}

/* ---------- END GAME (preserve original) ---------- */
function endGame(){
  gameRunning = false;
  const gm = document.getElementById('game-message');
  gm.textContent = 'GAME OVER';
  gm.style.display = 'block';
  try{ window.parent.postMessage({ type: "submitScore", score: score }, "*"); }catch(e){}
}

/* ---------- INPUT ---------- */
document.querySelectorAll('#mobileControls button').forEach(b=>{
  b.onclick = ()=>{
    unlockAudio();
    pacman.nextDir = b.dataset.dir;
    hasInput = true;
  };
});
window.onkeydown = e=>{
  if(e.key.includes('Arrow')){
    unlockAudio();
    pacman.nextDir = e.key.replace('Arrow','').toLowerCase();
    hasInput = true;
  }
};

/* Support external trigger used previously (paySuccess) */
window.addEventListener('message', (e)=>{
  if(e.data && e.data.type === 'paySuccess'){
    // Reset and then start (same as original flow)
    resetGame();
    startGame();
  }
});

/* ---------- STARTUP ---------- */
resetGame();
requestAnimationFrame(gameLoop);

})();
</script>
</body>
</html>
