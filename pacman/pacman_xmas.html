<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pacman XMAS - Santa vs Reindeer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  /* Layout: canvas + pad dalam flow kolom supaya pad tidak meng-overlay di mobile */
  html,body{
    margin:0;
    background:#000;
    height:100%;
    min-height:100vh;
    display:flex;
    justify-content:center;
    align-items:flex-start;
    font-family:Arial, Helvetica, sans-serif;
    padding:12px;
    box-sizing:border-box;
  }

  #gameWrapper{
    width: calc(20 * 20px + 40px); /* fallback */
    max-width: 92vw;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:12px;
    position: relative; /* Penting untuk overlay menu */
  }

  canvas{
    background:#020617;
    border-radius:10px;
    display:block;
    box-shadow: 0 8px 24px rgba(0,0,0,0.6);
    image-rendering: optimizeSpeed;
  }

  /* ================== MENU OVERLAY BARU ================== */
  #gameMenuOverlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
    border-radius: 10px;
    display: none; /* KRITIS: Sembunyikan secara default */
  }
  #gameMenuOverlay h3 {
      color: #ff0000;
      margin-bottom: 20px;
  }
  .mode-button {
      width: 90%;
      max-width: 300px;
      padding: 15px;
      margin: 8px 0;
      border: 2px solid #00ffae;
      background-color: #020617;
      color: white;
      font-size: 16px;
      font-weight: bold;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.2s;
  }
  .mode-button:hover {
      background-color: #b91c1c;
  }
  .mode-button .fee {
      font-size: 0.9em;
      color: #00ffae;
  }
  
  #ui{
    position:relative;
    color:#fff;
    z-index:2;
    align-self:flex-start;
    display:flex;
    justify-content:space-between; 
    width:100%;
    margin-bottom: -10px; 
  }

  /* FIX: Timer Display */
  #time-display-wrapper {
      font-weight: bold;
      color: #00ffae;
      text-shadow: 0 0 3px black;
  }
  
  #game-message{
    color:white;
    background:rgba(0,0,0,.6);
    padding:6px 10px;
    border-radius:8px;
    display:none;
    z-index:12;
    position:absolute; /* Posisikan di atas canvas */
    top: 50%;
    transform: translateY(-50%);
  }

  /* Mobile D-PAD: placed under canvas (not fixed) */
  #mobileControls{
    position:relative;
    margin-top:6px;
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:8px;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  
  /* FIX: Tombol lebih besar untuk touch yang lebih baik */
  #mobileControls button{
    width: 70px; /* Dulu 64px */
    height: 70px; /* Dulu 64px */
    border-radius:10px;border:0;
    background:linear-gradient(90deg,#cc0000,#16a34a);color:#fff;font-size:22px;
    display:inline-flex;align-items:center;justify-content:center;
    box-shadow:0 4px rgba(0,0,0,0.4);
    touch-action: manipulation;
  }
  .dpad-row{display:flex;align-items:center;gap:8px}
  
  /* FIX: Sesuaikan pengisi tengah dengan ukuran tombol yang baru */
  .center-filler{width: 70px; height: 70px;}

  /* Desktop: hide mobile pad, allow centering large canvas */
  @media(min-width:900px){
    body{align-items:center}
    #gameWrapper{max-width:760px}
    #mobileControls{display:none}
  }

  /* ensure small screens canvas fits and leaves room for pad */
  @media(max-width:480px){
    #gameWrapper{ width: 90vw; }
  }
</style>
</head>

<body>
  <div id="gameWrapper">
    
    <div id="gameMenuOverlay" style="display: none;">
        <h3 id="menu-title">SELECT GAME MODE</h3>
        <p id="menu-status" style="color:#00ffae; margin-bottom: 20px;">Wallet is not connected.</p>
        
        <button class="mode-button" data-mode="Classic" data-fee="0.01" data-mult="1" data-time="null" disabled>
            Classic Mode (x1 Score)<br><span class="fee">Fee: 0.01 SOMI</span>
        </button>
        <button class="mode-button" data-mode="TimeAttack" data-fee="0.03" data-mult="2" data-time="90" disabled>
            Time Attack (90s, x2 Score)<br><span class="fee">Fee: 0.03 SOMI</span>
        </button>
        <button class="mode-button" data-mode="Hardcore" data-fee="0.05" data-mult="4" data-time="null" disabled>
            Hardcore (1 Life, x4 Score)<br><span class="fee">Fee: 0.05 SOMI</span>
        </button>
        
        <button id="btnConnectMenu" class="mode-button" style="margin-top: 25px; background-color: #00b300;" disabled>
            Connect Wallet
        </button>

        <button id="btnLeaderboardMenu" class="mode-button" style="margin-top: 15px; background-color: #1e90ff;">
            View Leaderboard
        </button>
    </div>
    
    <div id="ui">
        <div>Score: <span id="current-score-display">0</span></div>
        <div id="game-info">
            <span id="time-display-wrapper" style="margin-right: 15px; display: none;">Time: <span id="time-display">0</span>s</span>
            <span>Lives: <span id="lives-display">3</span></span>
        </div>
    </div>
    <div id="game-message"></div>

    <canvas id="pacman-canvas" aria-label="Pacman XMAS game"></canvas>

    <div id="mobileControls" aria-hidden="false">
      <button data-dir="up" id="btn-up">↑</button>
      <div class="dpad-row">
        <button data-dir="left" id="btn-left">←</button>
        <div class="center-filler" aria-hidden="true"></div>
        <button data-dir="right" id="btn-right">→</button>
      </div>
      <button data-dir="down" id="btn-down">↓</button>
    </div>
  </div>

<script>
(() => {
const canvas = document.getElementById("pacman-canvas");
const ctx = canvas.getContext("2d");
const TILE = 20;
const $ = (id) => document.getElementById(id);
const ethers = window.parent.ethers; // Ambil object ethers dari parent (app.js/index.html)

/* ================== MAP ================== */
const GAME_MAP = [
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,2,1],
[1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1],
[1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],
[0,0,0,0,1,2,1,0,0,0,0,0,0,1,2,1,0,0,0,0],
[1,1,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1],
[1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1],
[1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1],
[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const MAP_W = GAME_MAP[0].length;
const MAP_H = GAME_MAP.length;

/* set canvas size based on map */
canvas.width = MAP_W * TILE;
canvas.height = MAP_H * TILE;

/* utility rounded rect */
function roundRect(ctx, x, y, w, h, r) {
  if (r === undefined) r = 6;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}

/* ========== STATE ========== */
let mapData, pacman, ghosts, score = 0, playerLives = 3;
let lastMove = 0;
let gameRunning = false;
let ghostActive = false;
const MOVE_INTERVAL = 240;

// State untuk Mode Game
let gameMode = 'Classic';
let scoreMultiplier = 1;
let timeLimit = null; // in seconds
let gameTimer = null; // Interval timer ID
let gameTimeRemaining = null; 

/* SECURITY: allowLocalPlay sekarang hanya untuk mengunci input setelah game dimulai*/
let allowGameInput = false; 
let isSubmissionSent = false;
let isWalletConnected = false; 


/* ========== UI UPDATERS ========== */
function updateScoreDisplay() {
    $("#current-score-display").textContent = score;
}
function updateLivesDisplay() {
    $("#lives-display").textContent = playerLives;
}
function updateTimerDisplay(time) {
    if ($("#time-display-wrapper")) {
        $("#time-display-wrapper").style.display = timeLimit ? 'inline' : 'none';
    }
    if ($("#time-display")) {
        $("#time-display").textContent = time;
    }
}
function updateMenuState() {
    const menu = $("#gameMenuOverlay");
    const menuStatus = $("#menu-status");
    const modeButtons = document.querySelectorAll('.mode-button[data-mode]');
    const connectButton = $("#btnConnectMenu");

    if (isWalletConnected) {
        menuStatus.textContent = "Wallet Connected! Select mode to Play.";
        connectButton.style.display = 'none';
        modeButtons.forEach(btn => btn.disabled = false);
    } else {
        menuStatus.textContent = "Please connect wallet to play on-chain.";
        connectButton.style.display = 'block';
        connectButton.disabled = false;
        modeButtons.forEach(btn => btn.disabled = true);
    }
}

/* ========== INIT ========== */
function resetGame(){
  mapData = GAME_MAP.map(r=>[...r]);
  pacman = {x:1,y:1,dir:"right",next:"right"};
  ghosts = [
    {x:9,y:9,color:"#ff0033", antlerColor:"#964B00", noseColor:"#cc0000"},
    {x:10,y:9,color:"#00b300", antlerColor:"#964B00", noseColor:"#556B2F"},
    {x:8,y:9,color:"#1e90ff", antlerColor:"#964B00", noseColor:"#87CEFA"}
  ];
  
  // RESET STATE MODE
  gameMode = 'Classic';
  scoreMultiplier = 1;
  timeLimit = null;
  playerLives = 3;
  clearGameTimer();
  
  score = 0;
  isSubmissionSent = false; 
  updateScoreDisplay();
  updateLivesDisplay();
  updateTimerDisplay(0);
  
  $("#game-message").style.display = "none";
  gameRunning = false;
  ghostActive = false;
  allowGameInput = false;
}

// BARU: Fungsi untuk menampilkan menu
function showGameMenu() {
    $("#gameMenuOverlay").style.display = "flex";
    $("#menu-title").textContent = "SELECT GAME MODE";
    $("#game-message").style.display = "none";
    if (!isWalletConnected) {
        // Minta status koneksi saat menu muncul
        parent.postMessage({ type: "requestConnectWallet" }, "*");
    } else {
        updateMenuState();
    }
}


/* (fungsi drawMap, drawPacman, drawGhosts) */
function drawMap(){
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      const t = mapData[y][x];
      if(t===1){
        ctx.fillStyle="#b91c1c";
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        ctx.strokeStyle="rgba(249,250,251,0.6)";
        ctx.lineWidth=1;
        ctx.strokeRect(x*TILE+0.5,y*TILE+0.5,TILE-1,TILE-1);
      } else {
        ctx.fillStyle="#020617";
        ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
        if(t===2){
          ctx.fillStyle="#ffd700";
          ctx.beginPath();
          ctx.arc(x*TILE+TILE/2,y*TILE+TILE/2,3,0,Math.PI*2);
          ctx.fill();
        }
      }
    }
  }
}

function drawPacman(){
  const wobbleY = Math.sin(Date.now() / 150) * 1.5;
  const x = pacman.x*TILE + TILE/2;
  const y = pacman.y*TILE + TILE/2 + wobbleY;
  const mouth = Math.abs(Math.sin(Date.now()/120))*0.5;
  const angle = {right:0,left:Math.PI,up:-Math.PI/2,down:Math.PI/2}[pacman.dir];

  ctx.fillStyle="#facc15";
  ctx.beginPath();
  ctx.moveTo(x,y);
  ctx.arc(x,y,TILE/2-2,angle+mouth*0.6,angle-mouth*0.6+Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(x, y + TILE/8, TILE/3.5, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle="#cc0000";
  ctx.beginPath();
  ctx.moveTo(x - TILE*0.35, y - TILE*0.3);
  ctx.lineTo(x + TILE*0.35, y - TILE*0.3);
  ctx.lineTo(x, y - TILE*0.8);
  ctx.closePath();
  ctx.fill();

  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(x, y - TILE*0.8, 3.5, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle="white";
  ctx.fillRect(x - TILE*0.35, y - TILE*0.3, TILE*0.7, 3);
}

function drawGhosts(){
  ghosts.forEach(g=>{
    const wobbleY = Math.sin(Date.now() / 150 + g.x * 0.5) * 1.5;
    const x = g.x*TILE + TILE/2;
    const y = g.y*TILE + TILE/2 + wobbleY;
    const size = TILE * 0.45;
    const headWobble = Math.sin(Date.now() / 200) * 1;

    ctx.save();
    ctx.shadowBlur = 8;
    ctx.shadowColor = g.color;
    ctx.fillStyle = g.color;
    roundRect(ctx, x - size, y - size, size * 2, size * 2, 6);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.arc(x - TILE*0.15, y - TILE*0.15, 2, 0, Math.PI*2);
    ctx.arc(x + TILE*0.15, y - TILE*0.15, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle="black";
    ctx.beginPath();
    ctx.arc(x - TILE*0.15 + headWobble, y - TILE*0.15, 1, 0, Math.PI*2);
    ctx.arc(x + TILE*0.15 + headWobble, y - TILE*0.15, 1, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle=g.noseColor;
    ctx.beginPath();
    ctx.arc(x, y + TILE*0.25, 3, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle=g.antlerColor;
    ctx.fillRect(x - TILE*0.35, y - TILE*0.4, 2, 5);
    ctx.fillRect(x - TILE*0.35 + 2, y - TILE*0.4 - 2, 5, 2);
    ctx.fillRect(x + TILE*0.35 - 2, y - TILE*0.4, 2, 5);
    ctx.fillRect(x + TILE*0.35 - 7, y - TILE*0.4 - 2, 5, 2);
  });
}

function movePacman(){
    // logic movePacman
    const nextDir = pacman.next;
    let nextX = pacman.x;
    let nextY = pacman.y;

    // Check next move based on desired direction
    const checkDir = (dir) => {
        let tx = pacman.x, ty = pacman.y;
        if (dir === 'up') ty--;
        else if (dir === 'down') ty++;
        else if (dir === 'left') tx--;
        else if (dir === 'right') tx++;
        return mapData[ty] && mapData[ty][tx] !== 1;
    };

    // If next direction is valid, use it
    if (checkDir(nextDir)) {
        pacman.dir = nextDir;
    }

    // Move in current confirmed direction
    if (pacman.dir === 'up') nextY--;
    else if (pacman.dir === 'down') nextY++;
    else if (pacman.dir === 'left') nextX--;
    else if (pacman.dir === 'right') nextX++;

    // Check if new position is open
    if (mapData[nextY] && mapData[nextY][nextX] !== 1) {
        pacman.x = nextX;
        pacman.y = nextY;
    } else {
        // If current direction is blocked, try next desired direction (to prevent sticking)
        if (pacman.dir !== nextDir && checkDir(nextDir)) {
             pacman.dir = nextDir;
             movePacman(); // Re-run move logic with new direction
        }
    }
    
    // Teleport logic
    if (pacman.x === 0 && pacman.y === 9 && pacman.dir === 'left') {
        pacman.x = MAP_W - 1;
    } else if (pacman.x === MAP_W - 1 && pacman.y === 9 && pacman.dir === 'right') {
        pacman.x = 0;
    }
}

function moveGhosts(){ 
    // Simplified logic: move towards pacman unless blocked
    ghosts.forEach(g => {
        if (!ghostActive) return;

        let dx = pacman.x - g.x;
        let dy = pacman.y - g.y;
        let moved = false;
        let directions = [];

        if (Math.abs(dx) > Math.abs(dy)) {
            directions = dx > 0 ? ['right', 'up', 'down', 'left'] : ['left', 'up', 'down', 'right'];
        } else {
            directions = dy > 0 ? ['down', 'left', 'right', 'up'] : ['up', 'left', 'right', 'down'];
        }

        for (const dir of directions) {
            let nextX = g.x, nextY = g.y;
            if (dir === 'up') nextY--;
            else if (dir === 'down') nextY++;
            else if (dir === 'left') nextX--;
            else if (dir === 'right') nextX++;

            if (mapData[nextY] && mapData[nextY][nextX] !== 1) {
                g.x = nextX;
                g.y = nextY;
                moved = true;
                break;
            }
        }
        
        // Random move if stuck or teleport
        if (!moved || (g.x === 0 && g.y === 9) || (g.x === MAP_W - 1 && g.y === 9)) {
            let options = ['up', 'down', 'left', 'right'];
            if (Math.random() < 0.5) options.reverse(); // Add variety

            for (const dir of options) {
                let nextX = g.x, nextY = g.y;
                if (dir === 'up') nextY--;
                else if (dir === 'down') nextY++;
                else if (dir === 'left') nextX--;
                else if (dir === 'right') nextX++;

                if (mapData[nextY] && mapData[nextY][nextX] !== 1) {
                    g.x = nextX;
                    g.y = nextY;
                    break;
                }
            }
        }
    });
}

function resetPositions() {
    pacman.x = 1; pacman.y = 1; pacman.dir = "right"; pacman.next = "right";
    ghosts[0] = {x:9,y:9,color:"#ff0033", antlerColor:"#964B00", noseColor:"#cc0000"};
    ghosts[1] = {x:10,y:9,color:"#00b300", antlerColor:"#964B00", noseColor:"#556B2F"};
    ghosts[2] = {x:8,y:9,color:"#1e90ff", antlerColor:"#964B00", noseColor:"#87CEFA"};
    
    const gm = $("#game-message");
    gm.textContent = `LIFE LOST! Remaining: ${playerLives}`;
    gm.style.display = "block";
    setTimeout(() => gm.style.display = "none", 1500);
    
    ghostActive = true;
    gameRunning = true;
    lastMove = performance.now();
}

function checkCollision(){
  if(mapData[pacman.y][pacman.x] === 2){
    mapData[pacman.y][pacman.x] = 0;
    score += 10 * scoreMultiplier; // Gunakan multiplier
    updateScoreDisplay();
    parent.postMessage({ type: "dotEaten" }, "*");
  }
  for(const g of ghosts){
    if(g.x === pacman.x && g.y === pacman.y){
        playerLives--;
        updateLivesDisplay();
        
        if (playerLives <= 0) {
            gameOver();
            return;
        } else {
            ghostActive = false;
            gameRunning = false;
            setTimeout(resetPositions, 1000); 
            return;
        }
    }
  }
  let win = true;
  for(let y=0;y<mapData.length;y++){
    for(let x=0;x<mapData[y].length;x++){
      if(mapData[y][x] === 2) { win = false; break; }
    }
    if(!win) break;
  }
  if(win){
    gameRunning = false;
    clearGameTimer();
    const finalScore = score; // Skor sudah dikalikan saat makan dot
    const gm = $("#game-message");
    gm.textContent = `YOU WIN! Final Score: ${finalScore} (x${scoreMultiplier})`;
    gm.style.display = "block";
    if (!isSubmissionSent) {
        parent.postMessage({ type: "submitScore", score: finalScore }, "*");
        isSubmissionSent = true;
    }
    // TAMPILKAN MENU SETELAH MENANG
    setTimeout(showGameMenu, 2000); 
  }
}

function gameOver(){
  gameRunning = false;
  clearGameTimer();
  if (isSubmissionSent) return; 

  const finalScore = score; // Skor sudah dikalikan saat makan dot
  const gm = $("#game-message");
  gm.textContent = `GAME OVER! Final Score: ${finalScore} (x${scoreMultiplier})`;
  gm.style.display = "block";
  
  if (!isSubmissionSent) {
    parent.postMessage({ type: "submitScore", score: finalScore }, "*");
    isSubmissionSent = true;
  }
  
  // TAMPILKAN MENU SETELAH GAME OVER
  setTimeout(showGameMenu, 2000); 
}

function startGameTimer(seconds) {
    gameTimeRemaining = seconds;
    updateTimerDisplay(gameTimeRemaining);
    
    gameTimer = setInterval(() => {
        gameTimeRemaining--;
        updateTimerDisplay(gameTimeRemaining); 
        
        if (gameTimeRemaining <= 0) {
            clearInterval(gameTimer);
            $("#game-message").textContent = "TIME UP! GAME OVER!";
            $("#game-message").style.display = "block";
            gameOver();
        }
    }, 1000);
}

function clearGameTimer() {
    if (gameTimer) {
        clearInterval(gameTimer);
        gameTimer = null;
    }
    gameTimeRemaining = null;
    updateTimerDisplay(0);
}

function startCountdownAndPlay(){
  $("#gameMenuOverlay").style.display = "none";
  const gm = $("#game-message");
  let count = 3;
  gm.style.display = "block";
  gm.textContent = `READY! Mode: ${gameMode}`;
  const t = setInterval(()=>{
    count--;
    if(count >= 0) gm.textContent = "READY " + count;
    if(count < 0){
      clearInterval(t);
      gm.style.display = "none";
      ghostActive = true;
      gameRunning = true;
      allowGameInput = true; // Buka input saat game dimulai
      lastMove = performance.now();
      
      if (gameMode === 'TimeAttack' && timeLimit) {
          startGameTimer(timeLimit);
      }
    }
  }, 1000);
}


/* ========== LOOP ========== */
function loop(ts){
  if(gameRunning && ts - lastMove > MOVE_INTERVAL){
    movePacman();
    moveGhosts();
    checkCollision();
    lastMove = ts;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();
  drawPacman();
  drawGhosts();
  requestAnimationFrame(loop);
}

/* ========== EVENT LISTENERS BARU (Untuk Menu) ========== */
document.addEventListener('DOMContentLoaded', () => {
    
    // Handler untuk tombol Connect Wallet di menu
    $("#btnConnectMenu").addEventListener('click', () => {
        parent.postMessage({ type: "requestConnectWallet" }, "*");
        $("#menu-status").textContent = "Connecting Wallet... please wait for pop-up.";
        $("#btnConnectMenu").disabled = true;
    });
    
    // Handler BARU untuk tombol Leaderboard
    $("#btnLeaderboardMenu").addEventListener('click', () => {
        // Kirim sinyal ke app.js untuk beralih tampilan
        parent.postMessage({ type: "showLeaderboardView" }, "*");
    });

    // Handler untuk semua tombol mode game
    document.querySelectorAll('.mode-button[data-mode]').forEach(btn => {
        btn.addEventListener('click', () => {
            if (!isWalletConnected) {
                alert("Please connect your wallet first.");
                return;
            }
            
            const modeName = btn.getAttribute('data-mode');
            const feeEth = btn.getAttribute('data-fee');
            const multiplier = parseInt(btn.getAttribute('data-mult'));
            const time = btn.getAttribute('data-time') === 'null' ? null : parseInt(btn.getAttribute('data-time'));

            // Mengubah fee SOMI string menjadi BigNumber Wei
            if (!ethers) {
                alert("Ethers library not loaded. Cannot process transaction.");
                return;
            }
            const feeWei = ethers.utils.parseEther(feeEth);
            
            // Mengirim request transaksi ke app.js
            parent.postMessage({ 
                type: "requestStartTx",
                modeName: modeName,
                feeWei: feeWei.toString(),
                multiplier: multiplier,
                timeLimit: time
            }, "*");
            
            // Set game state sementara (untuk ditampilkan di pesan loading)
            gameMode = modeName;
            scoreMultiplier = multiplier;
            timeLimit = time;
            
            $("#gameMenuOverlay").style.display = "none";
            $("#game-message").textContent = "Waiting for Wallet Confirmation...";
            $("#game-message").style.display = "block";
        });
    });
});

/* ========== MESSAGES & CONTROLS ========== */
window.addEventListener("message", (e) => {
  const d = e.data || {};

  // Sinyal dari app.js saat tombol Play di luar diklik
  if(d.type === "showGameMenu"){
      resetGame();
      showGameMenu();
      return;
  }
  
  // Sinyal dari app.js setelah connectWallet sukses
  if(d.type === "walletConnected"){
      isWalletConnected = true;
      updateMenuState();
      return;
  }

  // Sinyal dari app.js saat transaksi sukses
  if(d.type === "paySuccess"){
    // Terima parameter mode
    gameMode = d.gameMode || 'Classic';
    scoreMultiplier = d.scoreMultiplier || 1;
    timeLimit = d.timeLimit || null;
    
    if (gameMode === 'Hardcore') {
        playerLives = 1;
    } else {
        playerLives = 3;
    }
    updateLivesDisplay();

    resetGame(); 
    startCountdownAndPlay();
    return;
  }
  
  // Sinyal dari app.js bahwa Tx Start Gagal (Cancel/Error)
  if (d.type === "payFailed") {
      $("#menu-title").textContent = "TRANSACTION FAILED";
      $("#menu-status").textContent = "Please select mode to play again.";
      showGameMenu();
      resetGame();
      return;
  }

  // Sinyal dari app.js saat menunggu Tx Start
  if(d.type === "waitingForTx"){
      const gm = $("#game-message");
      gm.textContent = "Waiting for Blockchain Transaction...";
      gm.style.display = "block";
      gameRunning = false;
      ghostActive = false;
      return;
  }

  // Sinyal dari app.js saat menunggu Tx Score
  if(d.type === "waitingForScoreTx"){
      const gm = $("#game-message");
      gm.textContent = "Submitting Score to Blockchain...";
      gm.style.display = "block";
      gameRunning = false;
      ghostActive = false;
      return;
  }
  
  // Sinyal dari app.js setelah Score Submission Selesai/Gagal
  if (d.type === "scoreSubmissionComplete" || d.type === "scoreSubmissionFailed") {
      const title = d.type === "scoreSubmissionComplete" ? "SCORE SUBMITTED!" : "SCORE SUBMISSION FAILED";
      const status = d.type === "scoreSubmissionComplete" ? "Score berhasil dicatat di Leaderboard." : "Gagal mencatat skor, silakan coba lagi.";
      
      $("#menu-title").textContent = title;
      $("#menu-status").textContent = status;
      showGameMenu(); // Tampilkan menu lagi
      resetGame();
      return;
  }

  if(d.type === "dotEaten") { parent.postMessage({ type: "dotEaten" }, "*"); return; }
  if(d.type === "forceReset") { resetGame(); return; }

});

/* FIX: Fungsi untuk mengatur input internal D-Pad/Keyboard */
function handleGameInput(direction){
  if(direction && typeof direction === "string"){
    pacman.next = direction.toLowerCase();
  }
}

/* INPUT HANDLERS - gated by allowGameInput */
document.querySelectorAll("#mobileControls button").forEach(btn=>{
  const dir = btn.getAttribute("data-dir");
  const start = (ev) => {
    ev.preventDefault();
    btn.style.transform = "translateY(2px)";
    
    if(!allowGameInput){
      // Tampilkan menu jika tidak ada input yang diizinkan
      $("#gameMenuOverlay").style.display = "flex";
      return;
    }
    
    handleGameInput(dir); 
  };
  const end = (ev) => {
    ev.preventDefault();
    btn.style.transform = "";
  };
  btn.addEventListener("touchstart", start, {passive:false});
  btn.addEventListener("mousedown", start);
  btn.addEventListener("touchend", end);
  btn.addEventListener("mouseup", end);
});

/* keyboard arrows: same gating */
window.addEventListener("keydown", (e)=>{
  if(e.key.includes("Arrow")){
    const dir = e.key.replace("Arrow","").toLowerCase();
    
    if(!allowGameInput){
      $("#gameMenuOverlay").style.display = "flex";
      return;
    }
    
    handleGameInput(dir);
  }
});

/* ========== STARTUP ========== */
resetGame();
requestAnimationFrame(loop);

})();
</script>
</body>
</html>
